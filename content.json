{"meta":{"title":"郑林飞","subtitle":null,"description":null,"author":"郑林飞","url":"http://yoursite.com"},"pages":[{"title":"郑林飞个人简介","date":"2018-01-28T20:06:19.000Z","updated":"2018-01-28T12:07:19.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介"}],"posts":[{"title":"给RecyclerView加上折叠的效果","slug":"给RecyclerView加上折叠的效果","date":"2018-02-22T15:37:21.000Z","updated":"2018-02-22T07:46:52.000Z","comments":true,"path":"2018/02/22/给RecyclerView加上折叠的效果/","link":"","permalink":"http://yoursite.com/2018/02/22/给RecyclerView加上折叠的效果/","excerpt":"","text":"RecyclerView 有很高的自由度，可以说只有想不到没有做不到。这次用超简单的方法，让 RecyclerView 带上折叠的效果。 效果是这样的。 总结一下这个列表的特点，就是以下三点： 重叠效果； 层次感； 首项的差动。下面我们来一个个解决。 我们新建一个 ParallaxRecyclerView，让它继承 RecyclerView，并使用 LinearLayoutManager 作为布局管理器。 重叠效果 其实就是每一项都搭一部分在它前面那项而已。我们知道，RecyclerView 可以通过设置 ItemDecoration来实现列表的间隔效果，有没有想过要是把间隔设为负数会怎么样？比如： 1234567addItemDecoration(new ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom = -dp2px(context, 10); &#125; &#125;); 没错，这就实现了我们的重叠效果。 层次感 在 Material Design里是有Z轴这个概念的，我们可以给控件设置垂直于屏幕的高度，让不在同一高度的控件看起来有层次感。当然，我们要用 Material Design 的控件才有这个属性，这里我用的是 CardView。 我们给 ParallaxRecyclerView 增加一个滑动监听，在 onScrolled 方法里面做如下设置： 12345678910111213141516LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();int firstPosition = layoutManager.findFirstVisibleItemPosition();int lastPosition = layoutManager.findLastVisibleItemPosition();int visibleCount = lastPosition - firstPosition;//重置控件的高度int elevation = 1;for (int i = firstPosition - 1; i &lt;= (firstPosition + visibleCount) + 1; i++) &#123; View view = layoutManager.findViewByPosition(i); if (view != null) &#123; if (view instanceof CardView) &#123; ((CardView) view).setCardElevation(dp2px(context, elevation)); elevation += 5; &#125; &#125;&#125; 其中，setCardElevation 方法就是用来给 CardView 设置高度的，这里让每一项的高度比它的上一项高 5dp。 首项的差动 最后，我们想给第一项增加一个差动效果，这个同样在 onScrolled方法里面做处理就好了： 123View firstView = layoutManager.findViewByPosition(firstPosition);float firstViewTop = firstView.getTop();firstView.setTranslationY(-firstViewTop / 2.0f); 这样相当于第一项的滑动速度变成原来的一半。但这也会导致一个问题， 由于改变了控件的位置，当这个控件被复用时，会出现位置不正确的情况。所以我们在设置高度的时候，可以顺便把控件的位置复原了： 1234float translationY = view.getTranslationY();if (i &gt; firstPosition &amp;&amp; translationY != 0) &#123; view.setTranslationY(0);&#125; 这样就完成了一个带有简单折叠效果的 RecyclerView 了，妥妥的。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Android性能优化","slug":"Android性能优化","date":"2018-02-22T14:06:01.000Z","updated":"2018-02-22T06:44:32.000Z","comments":true,"path":"2018/02/22/Android性能优化/","link":"","permalink":"http://yoursite.com/2018/02/22/Android性能优化/","excerpt":"","text":"Android性能优化，是Android开发中的重中之中，本文将讲述如何进行性能优化。 实际项目中的Android性能优化主要有如下几个方面： 编写高效代码—开发中总结出的一些小的性能Tips Layout布局优化 内存优化 编写高效代码编写高效代码的两个原则 不要写不需要的代码 不要分配不必要的内存 以上两个原则，似乎感觉是废话，但确实是编程的最高境界，也是我们编写代码的过程中时刻需要思考和注意的两个方面。 那么如何做到如上两点呢？下面列出了一些实际开发中的例子。 避免产生不必要的对象 例如： int的数组比Integer对象数组要好得多。两个平行的int数组要比一个（int,int）型的对象数组高效。这对于其他任何基本数据类型的组合都通用 两个平行数组Foo[],Bar[]会优于一个（Foo,Bar）对象的数组 通常来讲，尽量避免创建短时零时对象.少的对象创建意味着低频的垃圾回收 对象的分配和回收都是需要代价的；分配的内存越多，就会引起强制的内存回收；给用户体验增加小的停顿间隙，从而影响用户体验。 用户能感觉到卡顿的时间延迟是100ms ~ 200ms。 用静态代替虚拟 如果方法不需要访问某对像的字段，将该方法设置为静态，调用速度会提升15%~20% 对于常量使用static final static final int i = 1;static final String s = “a”; 注：这种优化仅仅是针对基本数据类型和String类型常量的，而非任意的引用类型。但尽可能的将常量声明为static final是一种好的做法。 避免内部的getter和setter 使用增强for循环 增强for循环要比普通循环快3倍 避免使用浮点数 通常，浮点数会比整型慢2/3 在没有JIT的设备上，调用方法所传递的对象采用具体的类型而非接口类型会更高效 void methodA(List list); void methodA(ArrayList list); 如上，后一种比前一种更高效。 数据库操作方法的优化尽量利用原生的SQL语句 原生的SQL省去了拼接sql语句的步骤，要比SqliteDatabase提供的insert、query、 update、delete等函数效率高。当数据库越大，差别也越大 当操作条数较多时，利用事务进行批处理 这样SQLite将把全部要执行的SQL语句先缓存在内存当中，然后等到COMMIT的时候一次性的写入数据库，这样数据库文件只被打开关闭了一次，效率自然大大的提高 12345db.beginTransaction(); for(Collection c:colls)&#123; insert(db, c);&#125; db.setTransactionSuccessful(); Http请求方式的选择Android 内置了两种HTTP方式:HttpURLConnection 和 Apache HttpClient。这两种都支持HTTPS、流式上传和下载、可配置超时、IPv6和连接池。在Gingerbread或者更高版本时，推荐使用HttpURLConnection。 这是因为： HttpURLConnection API 更简单，包更小。同时对传输数据的压缩和响应的缓存处理减少了网络带宽、提高了速度，也节省了电量。 优化布局Layouts是Android应用里直接影响用户体验的一个关键部分。如果Layout设计的不好，可能导致你的应用大量的内存占用从而导致UI响应很慢。Android SDK提供了工具帮助你分析你的Layouts的性能问题。 使用Hierarchy Viewer Hierarchy Viewer工具位于SDK \\tools\\目录下，该工具能分析出你的布局不合理和可以优化的地方。 大多数情况下，布局渲染时间差别较大的原因是在LinaerLayout里使用了layout_weight。这将会增加测量(Measure)的时间。你应该仔细的考虑是否有必要使用layout weight。 使用Lint 使用Lint — 查看你的view层级哪些地方可以优化 使用compound drawables - 一个包含了ImageView与TextView的LinearLayout可以被当作一个compound drawable来处理 使用 - 如果FramLayout仅仅是一个纯粹的（没有设置背景，间距等）布局根元素，我们可以使用merge标签来当作根标签 无用的分支 - 如果一个layout并没有任何子组件，那么可以被移除，这样可以提高效率 无用的父控件 - 如果一个layout只有子控件，没有兄弟控件，并且不是一个ScrollView或者根节点，而且没有设置背景，那么我们可以移除这个父控件，直接把子控件提升为父控件 深层次的layout - 尽量减少内嵌的层级，考虑使用更多平级的组件 RelativeLayout or GridLayout来提升布局性能，默认最大的深度是10 其他一些布局要点 使用include标签 使用ViewStub标签 优化App内存为了垃圾回收器能回收你系统的内存，你应该避免引起内存泄露，而且要在合适的时间点释放被引用的对象。 慎用Service Service执行完后台任务后要停止 使用IntentService IntentService不同于普通的Service之处是： 提交的task系统会post到子线程运行 当后台运行的task完成时，系统会stop掉IntentService Release memory when your user interface becomes hidden 例如，在该onStop（）里做释放资源（例如网络连接、注销广播等）的工作 使用优化后的集合容器 例如：SparseArray、SparseBooleanArray、LongSpareArray ….. 尽量避免使用枚举 相比于静态常量，枚举会有超过其两倍以上的内存开销，在android中需严格避免使用枚举 避免使用依赖注入框架 使用ProGuard消除没有使用的代码 使用zipalign优化和对齐你的apk 使用MAT分析和优化内存 I/O使用后需要关闭，数据库和Cursor等使用后要关闭 使用finalize()+MAT 分析内存泄露 end Android优化主要就是内存、布局和性能的优化，本文总结了Android中优化的一些知识点。如果还有其他我没有讲到的，欢迎给我留言。","categories":[],"tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"}]},{"title":"实现上滑屏幕，隐藏底部菜单栏","slug":"实现上滑屏幕，隐藏底部菜单栏","date":"2018-02-08T22:02:50.000Z","updated":"2018-02-08T14:19:55.000Z","comments":true,"path":"2018/02/09/实现上滑屏幕，隐藏底部菜单栏/","link":"","permalink":"http://yoursite.com/2018/02/09/实现上滑屏幕，隐藏底部菜单栏/","excerpt":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。","text":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。本文主要实现的功能是底部菜单栏随用户手势滑动而变化。 正常状态 上滑之后 布局代码这个功能实现起来比较简单，主要利用了CoordinatorLayout的layout_behavior的属性。具体代码如下： 123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/toolbar\"/&gt; &lt;include layout=\"@layout/container\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/bottom_navigation\" style=\"@style/Widget.Design.BottomNavigationView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_gravity=\"bottom\" android:background=\"@color/viewBackground\" app:elevation=\"16dp\" app:itemIconTint=\"@drawable/nav_item_color_state\" app:itemTextColor=\"@drawable/nav_item_color_state\" app:layout_behavior=\"com.testapp.widget.behavior.BottomNavigationBehavior\" app:menu=\"@menu/bottom_navigation_main\"/&gt; 上面是activity_main的布局代码，第一个是菜单栏，第二个是内容界面，第三个是bottom。bottom导航栏这里采用是BottomNavigationView，具体用法不再介绍。这里主要看一下BottomNavigationView的app:layout_behavior属性，该属性是协调布局特有的。网上的一版用法是 1app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" 虽然表面上看是一个字符串，其实在里面调用的也是一个view类。这次我们通过自定义这个behavior类，实现底部菜单栏的显隐性。 java实现类1234567891011121314151617181920212223242526272829303132333435public class BottomNavigationBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private ObjectAnimator outAnimator, inAnimator; public BottomNavigationBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; // 垂直滑动 @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0) &#123;// 上滑隐藏 if (outAnimator == null) &#123; outAnimator = ObjectAnimator.ofFloat(child, \"translationY\", 0, child.getHeight()); outAnimator.setDuration(200); &#125; if (!outAnimator.isRunning() &amp;&amp; child.getTranslationY() &lt;= 0) &#123; outAnimator.start(); &#125; &#125; else if (dy &lt; 0) &#123;// 下滑显示 if (inAnimator == null) &#123; inAnimator = ObjectAnimator.ofFloat(child, \"translationY\", child.getHeight(), 0); inAnimator.setDuration(200); &#125; if (!inAnimator.isRunning() &amp;&amp; child.getTranslationY() &gt;= child.getHeight()) &#123; inAnimator.start(); &#125; &#125; &#125;&#125; 这个类的就是刚刚那个app:layout_behavior=”com.meiji.toutiao.widget.behavior.BottomNavigationBehavior”属性标明的类，看起来很简单，继承了Behavior抽象类，然后实现了两个方法。 onStartNestedScroll：这个方法主要用于监听协调布局的子view的滚动事件，当此方法返回true，表示要消耗此动作，继而执行下面的onNestedPreScroll方法，我们在代码中返回的是，滚动轴是不是竖直滚动轴。如果是的话，就返回trueonNestedPreScroll：这个方法就比较简单了，当用户上滑的时候，隐藏底部菜单栏，这里使用了动画退出，使用了ObjectAnimator.ofFloat方法，第一个是view对象，指的就是bottom，第二个是Y轴的变化，第三个是Y轴变化的多少，接下来设置动画秒数。","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/组件/"}]},{"title":"通过H5唤起本地app","slug":"通过H5唤起本地app","date":"2018-02-05T21:33:43.000Z","updated":"2018-02-08T14:01:16.000Z","comments":true,"path":"2018/02/06/通过H5唤起本地app/","link":"","permalink":"http://yoursite.com/2018/02/06/通过H5唤起本地app/","excerpt":"在安卓手机的浏览器中调起本地app","text":"在安卓手机的浏览器中调起本地appH5如何打开或者说唤起手机本地的app，有以下两种： 第一种方式： 通过在html的a标签里面的href中直接配置android端的schema，当然，如果有host其他的配置，跟在后面就可以了，android端配置和代码如下： android端配置：12345678910111213&lt;activity android:name = \".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name = \"android.intent.action.MAIN\"/&gt; &lt;category android:name = \"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;data android:host=\"baidu.com\" android:scheme=\"testapp\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 注：如果这个是配置在启动页要和标签并列在一起，不然运行后手机app的图标会没有；注意schema协议要小写,否则会有不能响应的异常! html代码： 123456789&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"testapp://baidu.com/?pid=1\"&gt;打开app&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 这里我们来看看schema拼接协议的格式： &lt; a href=”[scheme]://[host]/[path]?[query]”&gt;启动应用程序&lt; /a&gt; 各个项目含义如下所示： scheme：判别启动的App。 host：适当记述 path：传值时必须的key ※没有也可以 query：获取值的Key和Value ※没有也可以 以上就能实现打开本地的app了，当然是在app存在的情况下，否则的话没有反应。 我们有些时候在唤起本地app的时候可能会向app传递一些参数，这些参数我们就可以配置在path或者query里，我们只需要在oncreate里面获取就可以了。 代码如下： 12345Intent intent = getIntent(); Uri uri = intent.getData(); if (uri != null) &#123; String pid = uri.getQueryParameter(\"pid\");&#125; 如果还想要获取android里面配置的schema协议的话，还可以这样: 12345678910111213141516171819202122232425Uri uri = getIntent().getData();if(uri != null) &#123; // 完整的url信息 String url = uri.toString(); Log.e(TAG, \"url: \" + uri); // scheme部分 String scheme = uri.getScheme(); Log.e(TAG, \"scheme: \" + scheme); // host部分 String host = uri.getHost(); Log.e(TAG, \"host: \" + host); //port部分 int port = uri.getPort(); Log.e(TAG, \"host: \" + port); // 访问路径 String path = uri.getPath(); Log.e(TAG, \"path: \" + path); List&lt;String&gt; pathSegments = uri.getPathSegments(); // Query部分 String query = uri.getQuery(); Log.e(TAG, \"query: \" + query); //获取指定参数值 String pid = uri.getQueryParameter(\"pid\"); Log.e(TAG, \"pid: \" + pid);&#125; 如何判断一个Schema是否有效 : 1234567PackageManager packageManager = getPackageManager();Intent intent = newIntent(Intent.ACTION_VIEW, Uri.parse(\"testapp://baidu.com:80/article?goodsId=10011002\"));List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(intent, 0);booleanisValid = !activities.isEmpty();if(isValid) &#123; startActivity(intent);&#125; 这种方式也是我百度到的最多的方式，但是这样就带来了一个问题了，上面的需求说的是“在页面上有一个连接， 如果用户安装了APP，则点击打开对应的APP；如果用户没有安装，则点击打开对应的设置连接”，这明显就不符合需求了，这只能作为一些个别需求来使用了。 第二种方式： 既然通过在href配置schema协议不行，那就只能通过js代码来实现了，只有这样才能根据判断实现app有的时候就打开，没有的时候就跳转到下载链接下载。 我们知道，js是无法判断手机是否安装了某款app的，所以我们只能够曲线救国了，我们可以获取时间如果，长时间不能呼起app则默认为没有安装这款app，然后跳转到下载页。当然这不是我想出来的，是网上的各位大佬的想法。在这里又要细分为两种情况了。 1.直接唤醒 说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式兼容性较好，如果安装了app，在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器、QQ浏览器、百度浏览器 )和QQ客户端中，能唤醒。微信、新浪微博客户端、腾讯微博客户端无法唤醒。 代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;点击唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式。兼容性较好，如果安装了app，在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )和QQ客户端中，能唤醒。微信 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;a href=\"zjmobile://platformapi/startapp\" id=\"zjmobliestart\" target=\"_blank\"&gt;唤醒浙江移动手机营业厅！&lt;/a&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; return function()&#123; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;; &#125;applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.点击唤醒 说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面。兼容性一般：在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器 QQ浏览器、百度浏览器 )能唤醒。微信、QQ客户端、新浪微博客户端、 腾讯微博客户端无法唤醒。 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;直接唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面兼容性一般：在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )能唤醒。微信 QQ客户端 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;p id=\"zjmobliestart\"&gt;唤醒浙江移动手机营业厅！&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; window.location = 'zjmobile://platformapi/startapp'; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;document.getElementById(\"zjmobliestart\").onclick = applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样就完成了我们的需求了。 还要注意的是，如果是在微信中唤起本地app，手机的微信中，是利用微信内置的浏览器打开那个简单的HTML页面，注意：直接打开scheme://host/datastring是不可行的，微信不会把这串字符解析成网址，必须包装成网页才能借助微信的浏览器打开。进入后就是我们刚刚设计的页面。这个时候，直接点击“启动应用程序”是不会唤醒之前安装的APP的，因为微信做了屏蔽，你需要在右上角的菜单中选择“在浏览器中打开”。这个时候就可以唤醒你想唤醒的app了。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]}]}