{"meta":{"title":"郑林飞","subtitle":null,"description":null,"author":"郑林飞","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-06-05T10:07:45.987Z","updated":"2018-06-05T10:07:45.987Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-06-05T10:07:45.987Z","updated":"2018-06-05T10:07:45.987Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"慕课网笔记","date":"2018-04-14T17:19:02.000Z","updated":"2018-06-05T10:07:45.989Z","comments":true,"path":"imooc/index.html","permalink":"http://yoursite.com/imooc/index.html","excerpt":"","text":"1. APP性能优化之内存优化 2. Android互动直播APP开发入门 3. APP性能优化之内存优化 4. APP性能优化之内存优化"},{"title":"hexo","date":"2018-04-23T18:03:33.000Z","updated":"2018-06-05T10:07:45.988Z","comments":true,"path":"hexo/index.html","permalink":"http://yoursite.com/hexo/index.html","excerpt":"","text":"hexo迁移 https://www.jianshu.com/p/beb8d611340a"},{"title":"黑马程序员-打动面试官","date":"2018-05-03T11:59:26.000Z","updated":"2018-06-05T10:07:45.988Z","comments":true,"path":"ddmsg/index.html","permalink":"http://yoursite.com/ddmsg/index.html","excerpt":"","text":"请你自我介绍一下你自己一般人回答这个问题往往会进入误区，回答的过于平常，只说姓名、年龄、爱好、工作经验等，但是你们想到没有，其实这些信息你的个人简历上都有，那么面试官还问你干什么？其实，面试官最希望知道的是求职者能否胜任这份工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但一定要突出积极的个性和做事的能力，说得合情合理企业的面试官才会相信。企业很重视一个人的礼貌，求职者要尊重面试官，在回答每个问题之后还可以加一句“谢谢”，企业喜欢有礼貌的求职者。切记：回答面试官问题的时候一定要回答的自然，有底气，否则你给面试官留下一个“假”的印象。 如何才能打动面试官关键点就是你如何让用户相信你的工作能够完成，与人合作也完全没有问题（面试时，用人单位是最主要考虑你的是工作能否完成）。所以作为应聘者，要打开了说，要给人感觉挺可靠的。所以要抱着真诚努力的态度去争取这份工作。但真诚并不是代表着你要去很老实的去展现自己，老实是美德，但是太老实则会吃亏。要懂得适度的包装自己（月饼要包装才能卖高价、见网友要打扮就是这个道理）。 谈谈你对公司加班的看法实际上好多公司会问这个问题，并不证明一定要加班，只是有时候项目多了要加班，想提前测试你是否愿意为公司奉献。被面试官问到这道题，千千万万不要幼稚地反问面试官：“加班是否有加班费”？这样你是不会被公司录用的，因为我之前说过面试官想提前测试你是否愿意为公司奉献，更何况加班费在如今的IT行业的私企中已经不复存在，只有为数不多的公司现在还有。看到这里，肯定有人就说了，既然这样，那我就回答愿意加班了，你这样回答如果你入职了，公司可能让你往死里加班，谁让你当初愿意加班了，那么回答不愿意加班的话，相信大家已经能猜到后果了，这里我就不多说了。既然这样我们回答愿意不行，不愿意更不行，叫我们如何是好，接下来我就告诉大家在问到这到面试题该如何的回答：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班；或者说如果是工作需要我会义不容辞加班，我现在已经成家，生活上已经稳定，这样更能全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。这么回答之后，这道题你就顺利的过关了，公司喜欢录用聪明的人 谈谈你对薪资的要求未来五年的规划是怎样的1.如果应聘成功，我至少会稳定的呆两年，踏实的做好自己的本职工作。2.在工作中，会向高手请教，研究些新技术，提高自己的技术水平。3.目前的规划是要优先做一名技术高手，如果有可能的话，做管理也是可以考虑的。 你还有什么问题要问吗企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 你为什么选择我们的公司 面试前，对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！ 面试时候，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的PHP岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。 非技术面试注意点是什么应聘的时候，不要忽视了外表。应聘的时候，要展现自己对技术的理解、对程序员工作的理解。应聘的时候，要表现自己对工作的热情（特别喜欢这份工作），工作能力（能干好事）。应聘的时候，注意千万不要抱着写好简历（以为自己有技术就会有高工资）就等人家开工资的态度。应聘的时候，不要自曝其短，而要自曝其长（比如英语六级、微软xx证书等）。应聘的时候，工资不能够写的太低了。应聘的时候，如果学历写高中不会有面试机会。 如果你出现工作失误，给公司造成经济损失，你认为该怎么办 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望公司帮助解决。 分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中的人失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。 如果你做的一项工作受到上级表扬，主管却说是他做的，你该怎样此回答是针对面试官的问题，但是实际工作中千万别这么干，要不你会输的很惨，此处略去N个字）我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种： 我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。 他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。 谈谈你对跳槽的看法这道题，比较简单，大家可以在面试的时候在扩展一下。 正常的“跳槽”能促进人才合理流动，应该支持。 频繁的跳槽对单位和个人双方都不利，应该反对。 怎样才能进入知名大企业首先我们要知道知名大企业招聘要求大学生是211或985学校出来的，应该说是所有的行业都会有这种问题，并不仅仅是IT技术领域有这个问题。如果真想进入知名大企，可以走社招这条路，比如传智播客毕业的学生很多都是这么进入知名企业的。可先进入中小企业做一些核心项目，等能力提升了，再跳槽到大企业去。 你因工作比较突出，虽说得到领导肯定，但同事越来越孤立你，你该怎么办 成绩比较突出，得到领导的肯定是件好事情，以后更加努力。 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。 工作中，切勿伤害别人的自尊心。 不再领导前拨弄是非。 面试官如何评判应聘者的工资一些正规的大公司主要是根据以下四个方面进行评判（重要性从上至下）。 掌握的技术（通过笔试、项目经验、工作时间） 表达 学历 其他素质（如英语四六级等） 面试官评判应聘者工资的重要性之所以采取如此的顺序，根本原因在于面试官最最重要的是程序员能不能把工作做好，让公司放心。所以学员技术很重要，表达也很重要（技术牛但不会表达，也会让人怀疑技术实力）。其实，工作并不是我们想象的那么难，就算真的碰到问题，除了问可以同学，还可以问老师。 技术较差的学员应如何面试 多看技术面试题。面试题一定要仔细准备。 项目，一定要做出来，不做东西是不行的。还要总结出这些项目的特点和亮点。 技术弱的时候，就不停的说（技术强的时候，可以坐着等人说），一方面可以主动推出自己的亮点，另一方面也避免了让面试官提一些我们不太懂的技术问题。有时候我们说的亮点，刚好是面试者不懂的技术，反而会让他高看我们一眼，从而成功拿到OFFER!越怕说错 ，胆子越小，那么用人单位就越不敢用你。 不能说自己是来公司锻炼的，一方面显得你技术不行，另一方面也让人感觉你锻炼完了，你就会离开公司。如果万一不小心说了“锻炼”，那就要通过强调自己超强的学习能力，举出例子，比如全班第一名，比如技术的例子等。 面试要做好心理准备：经过一番面试后，心情被打击了，就降低了薪资标准，千万不要，要做好面试10家的准备。 如何介绍简历中的项目我们在跟面试官讲解的时候，讲解项目一定要围绕着以下几个方面： 项目名称 开发时间（这里有个注意点：时间不要说的太短，而应该把前期的构思、需求分析、准备工作等时间都可以加进去）； 项目描述（做什么的）； 项目职责（说清楚自己职责，同时为了提高自己的技术形象，可以将项目说大点）； 目使用的技术； 项目的亮点； 在自己的项目上可以想一些市面上没有但是自己觉得很有创意的点子。实现不实现都是无所谓了，但是你给面试官的印象会再上一个层次。 项目体会（可以说说：多人协作、命名规范、模块划分）； 你能否单独担起一个项目1.首先要向对方提问，问这个项目有多大2.听完对方的项目介绍后，要略作思考，感叹项目对于自己来说较为全新，希望有人带。3.如果确实没有人带，我也愿意尝试（不用怕，别忘记了自己认识的技术好的同学和老师）！4.谈自己为什么这么有信心（有工作经验的可以多谈自己的工作经验，没有工作经验的，可多谈自己的学习能力，要给公司以信心）。 面试时候无法表达时该怎么办 可以举例、可以要纸笔来画 面试题准备的时候，可以对自己要求高一些。不是停留在知道层面，而要进一步提高到知道而且我还能说出来的层面。能让别人听懂，这才是真正的懂。 在完成某项工作时，你认为自己的方式比领导要求的更好，你应该怎么做 原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作，并私下找领导分析下我的想法有哪些考虑是不周到的，这样也可以去提高自己。 还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。（注：这个你可以在面试的时候这么说，但一定要明确是面试官不是你将来的直接主管，而且实际中你也不要这么干！） 你会在我们这家单位呆多久 这不是自己单方面决定的，还要看公司，但是可以肯定的是，如果公司跟自己的职业发展一致，我是会一直干下去的。 以我对公司和现有职位的了解，如果能应聘上的话，目前来看至少可以稳定三年。 HR指责要薪太高怎么办 北京的生活成本高，3000元在北京生存很艰难，在饭店工作也可能不值这个，北京的PHP平均工资我也是有过了解的。同学大都是这个工资（注意：这个同学可以向HR强调是平时一起讨论问题的同学，暗示水平差不多)； 上几家都给我6千了，我没有去（觉得自己值多少钱，那就是值多少）； 我不是乱要价，我有能力完成完成上级交代的任务，创造出超过7000元价值的能力（强调自己的能力）； 对技术狂热，会沿着php道路一直往前走（强调自己对这份工作的热爱）； 再说公司会有试用期，试用期可以低于7000，我会在这个阶段证明我自己的能力，可以如果没有达到，公司也可以开除我。"},{"title":"Android面试题","date":"2018-03-03T19:16:04.000Z","updated":"2018-06-05T10:07:45.990Z","comments":true,"path":"ms-android/index.html","permalink":"http://yoursite.com/ms-android/index.html","excerpt":"","text":"Android的四大组件是哪些，它们的作用？Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑；Service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事务，定义好需要接收的Intent提供同步和异步的接口；ContentProvider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提供了更方便的途径；BroadcastReceiver：接收一种或者多种Intent作触发事件，接收相关消息转换成一条Notification，统一了Android的事件广播模型。 Activity的生命周期?onCreate() - onStart() - onResume() - onPause() - onstop() - onDestroy() - onRestart() 后台的Activity被系统回收怎么办?onSaveInstanceState()123456789protected void onSaveInstanceState(BundleoutState) &#123; super.onSaveInstanceState(outState); outState.putLong(\"id\",1234567890); &#125; public void onCreate(BundlesavedInstanceState) &#123; //判断savedInstanceState是不是空. //如果不为空就取出来 super.onCreate(savedInstanceState); &#125; android 横竖屏切换生命周期?不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 什么是ANR，如何避免它?用户操作在5秒内应用程序未做出响应，或者BroadcastReceiver在10秒内没有执行完毕。 Android的系统架构?Android系统架构从上往下为Linux内核层、运行库、应用程序框架层、应用程序层。 谈谈Android的IPC（进程间通信）机制?Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互。 如何将SQLite数据库与apk文件一起发布?可以将db文件复制到工程中的res\\raw目录中，raw中的文件不会被压缩。 4种启动模式? standard：默认 singleTop：如果有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。 singleTask：如果有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象。 singleInstance：启用一个新的栈， Service的两种启动方式?第一种：startService 1.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的startService(Intent)方法启动该Service4.不再使用时，调用stopService(Intent)方法停止该服务 使用这种start方式启动的Service的生命周期如下：onCreate() —&gt; onStartCommand()（onStart()方法已过时） —&gt; onDestory()。如果服务已经开启，不会重复的执行onCreate()，而是会调用onStart()和onStartCommand()。服务停止的时候调用 onDestory()。服务只会被停止一次。特点：一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。 第二种：bindService 1.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的bindService(Intent, ServiceConnection, int)方法启动该Service4.不再使用时，调用unbindService(ServiceConnection)方法停止该服务 使用这种start方式启动的Service的生命周期如下：onCreate() —&gt; onBind() —&gt; onunbind() —&gt; onDestory()特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。 Activity如与Service通信？可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法里执行相关操作。 两种注册、发送广播的方式?第一种：代码中动态注册123456789//new出上边定义好的BroadcastReceiverMyBroadCastReceiver yBroadCastReceiver = new MyBroadCastReceiver();//实例化过滤器并设置要过滤的广播 IntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");//注册广播 myContext.registerReceiver(smsBroadCastReceiver,intentFilter, \"android.permission.RECEIVE_SMS\", null); 第二种：Manifest.xml中静态注册123456&lt;receiver android:name=\".MyBroadCastReceiver\"&gt; &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt; &lt;intent-filter android:priority=\"20\"&gt; &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 两种注册广播的不同第一种不是常驻型广播，跟随程序的生命周期。第二种是常驻型，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。有两种方式分别发送两种不同的广播：通过mContext.sendBroadcast(Intent)或mContext.sendBroadcast(Intent, String)发送的是无序广播(后者加了权限)；通过mContext.sendOrderedBroadcast(Intent, String, BroadCastReceiver, Handler, int, String, Bundle)发送的是有序广播。 5种进程的优先级? 空进程 后台进程 服务进程 可见进程 前台进程 FragmentPageAdapter和FragmentPageStateAdapter的区别 FragmentPageAdapter在每次切换页面的的时候，是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响。 FragmentPageStateAdapter在每次切换页面的时候，是将Fragment进行回收，适合页面较多的Fragment使用，这样就不会消耗更多的内存。"},{"title":"我的秘密","date":"2018-04-14T16:47:07.000Z","updated":"2018-06-05T10:07:45.989Z","comments":true,"path":"list/index.html","permalink":"http://yoursite.com/list/index.html","excerpt":"","text":"1、 hexo 2、 慕课网笔记 3、 笔记 4、 黑马程序员-打动面试官 5、 笔记 5、 Android性能优化 面试题 1、 安卓 2、 Java 3、 算法 4、 http RxJava 1、 创建操作符 2、 变换操作符 3、 组合/合并操作符 4、 功能性操作符 5、 过滤操作符 6、 条件 / 布尔操作符"},{"title":"http面试题","date":"2018-05-18T11:43:35.000Z","updated":"2018-06-05T10:07:45.990Z","comments":true,"path":"ms-http/index.html","permalink":"http://yoursite.com/ms-http/index.html","excerpt":"","text":"HTTPS和HTTP的区别?HTTPS = HTTP + SSLHTTP 和 HTTPS 的不同之处 HTTP 是不安全的，而 HTTPS 是安全的 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层 HTTP 无需加密，而 HTTPS 对传输的数据进行加密 HTTP 无需证书，而 HTTPS 需要认证证书"},{"title":"Java面试题","date":"2018-05-18T11:36:26.000Z","updated":"2018-06-05T10:07:45.991Z","comments":true,"path":"ms-java/index.html","permalink":"http://yoursite.com/ms-java/index.html","excerpt":"","text":"Switch能否用string做参数？在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。 equals与==的区别?==比较的是2个对象的地址，而equals比较的是2个对象的内容。 String、StringBuffer与StringBuilder的区别?StringBuilder：线程非安全的 、StringBuffer：线程安全的a.如果要操作少量的数据用 = Stringb.单线程操作字符串缓冲区 下操作大量数据 = StringBuilderc.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer Collection与Collections的区别?Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。Collection是个java.util下的接口，它是各种集合结构的父接口。 Override和Overload的含义去区别?Overload：函数里面有相同的函数名但是参数名、返回值、类型不相同。Override：在子类继承父类的时候，将方法继承过来。 interface与abstract类的区别? 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的。 抽象类中可以包含静态方法，接口中不能包含静态方法。 一个类可以实现多个接口，但只能继承一个抽象类。 都不能被实例化。 接口里只能定义常量，不能定义普通成员变量；抽象类里则即可以定义普通成员变量，也可以定义静态常量。 解析XML的几种方式?DOM、SAX、PULL 设计模式六大原则? 要点 定义 描述 单一职责原则 不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 里氏替换原则 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。定义2：所有引用基类的地方必须能透明地使用其子类的对象。 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 依赖倒置原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 接口隔离原则 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 迪米特法则 一个对象应该对其他对象保持最少的了解。 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。解决方案：尽量降低类与类之间的耦合。 常用到的设计模式? 单例模式 懒汉式 123456789101112//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125; &#125; 饿汉式 123456789//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton &#123; private Singleton() &#123;&#125; private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() &#123; return single; &#125; &#125; 适配器模式 观察者模式 建造者模式"},{"title":"算法面试题","date":"2018-05-18T11:36:38.000Z","updated":"2018-06-05T10:07:45.991Z","comments":true,"path":"ms-suanfa/index.html","permalink":"http://yoursite.com/ms-suanfa/index.html","excerpt":"","text":"冒泡排序 基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。过程：比较相邻的两个数据，如果第二个数小，就交换位置。从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。继续重复上述过程，依次将第2.3…n-1个最小数排好位置。 123456789101112public static void sort(int[] arr) &#123; int temp;//临时变量 for (int i = 0; i &lt; arr.length - 1; i++) &#123;//表示趟数，一共arr.length-1次。 for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125;&#125; 选择排序基本思想：在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换；第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。 过程： 123456789101112131415public static void sort(int array[]) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125;&#125;"},{"title":"notebook","date":"2018-05-02T10:59:57.000Z","updated":"2018-06-05T10:07:45.994Z","comments":true,"path":"notebook/index.html","permalink":"http://yoursite.com/notebook/index.html","excerpt":"","text":"popupwindow动画1mTypePopupWindow.setAnimationStyle(R.style.popupwindow_anim); 1234&lt;style name=\"popupwindow_anim\"&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/popupwindow_anim_in&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/popupwindow_anim_out&lt;/item&gt; &lt;/style&gt; 修改DrawerLayout的阴影的颜色1mDrawer.setScrimColor(Color.parseColor(\"#20000000\")); LinearLayout自带的分割线12android:divider=\"@drawable/divider\"android:showDividers=\"middle\" 插值器InterpolatorAccelerateDecelerateInterpolator 在动画开始与介绍的地方速率改变比较慢，在中间的时候加速AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速AnticipateInterpolator 开始的时候向后然后向前甩AnticipateOvershootInterpolator 开始的时候向后然后向前甩一定值后返回最后的值BounceInterpolator 动画结束的时候弹起CycleInterpolator 动画循环播放特定的次数，速率改变沿着正弦曲线DecelerateInterpolator 在动画开始的地方快然后慢LinearInterpolator 以常量速率改变OvershootInterpolator 向前甩一定值后再回到原来位置"},{"title":"图文详解 变换操作符","date":"2018-05-24T12:04:18.000Z","updated":"2018-06-05T10:07:46.008Z","comments":true,"path":"rxjava2/index.html","permalink":"http://yoursite.com/rxjava2/index.html","excerpt":"","text":"Map( ) 作用对 被观察者发送的每1个事件都通过 指定的函数 处理，从而变换成另外一种事件 即， 将被观察者发送的事件转换为任意的类型事件。 应用场景数据类型转换 下面以将 使用Map（） 将事件的参数从 整型 变换成 字符串类型 为例子说明 12345678910111213141516171819202122// 采用RxJava基于事件流的链式操作Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // 1. 被观察者发送事件 = 参数为整型 = 1、2、3 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; // 2. 使用Map变换操作符中的Function函数对被观察者发送的事件进行统一变换：整型变换成字符串类型&#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return \"使用 Map变换操作符 将事件\" + integer + \"的参数从 整型\" + integer + \" 变换成 字符串类型\" + integer; &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; // 3. 观察者接收事件时，是接收到变换后的事件 = 字符串类型 @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); FlatMap( ) 作用将被观察者发送的事件序列进行 拆分 &amp; 单独转换，再合并成一个新的事件序列，最后再进行发送 原理 为事件序列中每个事件都创建一个 Observable 对象； 将对每个 原始事件 转换后的 新事件 都放入到对应 Observable对象； 将新建的每个Observable 都合并到一个 新建的、总的Observable 对象； 新建的、总的Observable 对象 将 新合并的事件序列 发送给观察者（Observer） 应用场景无序的将被观察者发送的整个事件序列进行变换 1234567891011121314151617181920212223242526// 采用RxJava基于事件流的链式操作Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; // 采用flatMap（）变换操作符&#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"我是事件 \" + integer + \"拆分后的子事件\" + i); // 通过flatMap中将被观察者生产的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件 // 最终合并，再发送给被观察者 &#125; return Observable.fromIterable(list); &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); 注：新合并生成的事件序列顺序是无序的，即 与旧序列发送事件的顺序无关 ConcatMap( ) 作用类似FlatMap（）操作符 与FlatMap（）的 区别在于：拆分 &amp; 重新合并生成的事件序列 的顺序 = 被观察者旧序列生产的顺序 原理 应用场景有序的将被观察者发送的整个事件序列进行变换 1234567891011121314151617181920212223242526// 采用RxJava基于事件流的链式操作Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; // 采用concatMap（）变换操作符&#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"我是事件 \" + integer + \"拆分后的子事件\" + i); // 通过concatMap中将被观察者生产的事件序列先进行拆分，再将每个事件转换为一个新的发送三个String事件 // 最终合并，再发送给被观察者 &#125; return Observable.fromIterable(list); &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125;&#125;); 注：新合并生成的事件序列顺序是有序的，即 严格按照旧序列发送事件的顺序做个通俗的总结，变量转List使用FlatMap或ConcatMap，其他时候使用Maphttps://blog.csdn.net/guiyu_1985/article/details/54647434 Buffer( ) 作用定期从 被观察者（Obervable）需要发送的事件中 获取一定数量的事件 &amp; 放到缓存区中，最终发送 原理 应用场景缓存被观察者发送的事件 12345678910111213141516171819202122232425// 被观察者 需要发送5个数字Observable.just(1, 2, 3, 4, 5) .buffer(3, 1) // 设置缓存区大小 &amp; 步长 // 缓存区大小 = 每次从被观察者中获取的事件数量 // 步长 = 每次获取新事件的数量 .subscribe(new Observer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(List&lt;Integer&gt; stringList) &#123; Log.d(TAG, \" 缓存区里的事件数量 = \" + stringList.size()); for (Integer value : stringList) &#123; Log.d(TAG, \" 事件 = \" + value); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 过程解释 至此，关于RxJava2中主要的变换操作符已经讲解完毕"},{"title":"最基础的操作符详解 - 创建操作符","date":"2018-05-22T15:48:22.000Z","updated":"2018-06-05T10:07:45.995Z","comments":true,"path":"rxjava1/index.html","permalink":"http://yoursite.com/rxjava1/index.html","excerpt":"","text":"基本创建create( ) 作用完整创建1个被观察者对象（Observable） RxJava 中创建被观察者对象最基本的操作符 1234567891011121314151617181920212223242526272829303132// 1. 通过creat（）创建被观察者对象Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; // 2. 在复写的subscribe（）里定义需要发送的事件 @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; // 至此，一个被观察者对象（Observable）就创建完毕&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; // 以下步骤仅为展示一个完整demo，可以忽略 // 3. 通过通过订阅（subscribe）连接观察者和被观察者 // 4. 创建观察者 &amp; 定义响应事件的行为 @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Integer value) &#123; Log.d(\"TAG\", \"接收到了事件\"+ value ); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125;&#125;); 快速创建 &amp; 发送事件just( ) 作用完整创建1个被观察者对象（Observable） 注：最多只能发送10个参数 应用场景快速创建 被观察者对象（Observable） &amp; 发送10个以下事件 12345678910111213141516171819202122232425// 1. 创建时传入整型1、2、3、4// 在创建后就会发送这些对象，相当于执行了onNext(1)、onNext(2)、onNext(3)、onNext(4)Observable.just(1, 2, 3,4) // 至此，一个Observable对象创建完毕，以下步骤仅为展示一个完整demo，可以忽略 // 2. 通过通过订阅（subscribe）连接观察者和被观察者 // 3. 创建观察者 &amp; 定义响应事件的行为 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Integer value) &#123; Log.d(\"TAG\", \"接收到了事件\"+ value ); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;); fromArray( ) 作用 快速创建1个被观察者对象（Observable） 发送事件的特点：直接发送 传入的数组数据 会将数组中的数据转换为Observable对象 应用场景 快速创建 被观察者对象（Observable） &amp; 发送10个以上事件（数组形式） 数组元素遍历 1234567891011121314151617181920212223// 1. 设置需要传入的数组Integer[] items = &#123; 0, 1, 2, 3, 4 &#125;;// 2. 创建被观察者对象（Observable）时传入数组// 在创建后就会将该数组转换成Observable &amp; 发送该对象中的所有数据Observable.fromArray(items) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(\"TAG\", \"接收到了事件\"+ value ); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;); fromIterable( ) 作用 快速创建1个被观察者对象（Observable） 发送事件的特点：直接发送 传入的集合List数据 会将数组中的数据转换为Observable对象 应用场景 快速创建 被观察者对象（Observable） &amp; 发送10个以上事件（集合形式） 数组元素遍历 12345678910111213141516171819202122232425// 1. 设置一个集合List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);// 2. 通过fromIterable()将集合中的对象 / 数据发送出去Observable.fromIterable(list) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(\"TAG\", \"接收到了事件\"+ value ); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;); 额外 // 下列方法一般用于测试使用 &lt;– empty() –&gt;// 该方法创建的被观察者对象发送事件的特点：仅发送Complete事件，直接通知完成Observable observable1=Observable.empty();// 即观察者接收后会直接调用onCompleted（） &lt;– error() –&gt;// 该方法创建的被观察者对象发送事件的特点：仅发送Error事件，直接通知异常// 可自定义异常Observable observable2=Observable.error(new RuntimeException())// 即观察者接收后会直接调用onError（） &lt;– never() –&gt;// 该方法创建的被观察者对象发送事件的特点：不发送任何事件Observable observable3=Observable.never();// 即观察者接收后什么都不调用 延迟创建defer( ) 作用直到有观察者（Observer ）订阅时，才动态创建被观察者对象（Observable） &amp; 发送事件 通过 Observable工厂方法创建被观察者对象（Observable）每次订阅后，都会得到一个刚创建的最新的Observable对象，这可以确保Observable对象里的数据是最新的 应用场景动态创建被观察者对象（Observable） &amp; 获取最新的Observable对象数据 1234567891011121314151617181920212223242526272829303132// 1. 第1次对i赋值Integer i = 10;// 2. 通过defer 定义被观察者对象// 注：此时被观察者对象还没创建Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; call() throws Exception &#123; return Observable.just(i); &#125;&#125;);// 2. 第2次对i赋值i = 15;// 3. 观察者开始订阅// 注：此时，才会调用defer（）创建被观察者对象（Observable）observable.subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(\"TAG\", \"接收到的整数是\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125;&#125;); timer( ) 作用 快速创建1个被观察者对象（Observable） 发送事件的特点：延迟指定时间后，发送1个数值0（Long类型） 本质 = 延迟指定时间后，调用一次 onNext(0) 应用场景延迟指定事件，发送一个0，一般用于检测 123456789101112131415161718192021// 该例子 = 延迟2s后，发送一个long类型数值Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; @Override public void onNext(Long value) &#123; Log.d(\"TAG\", \"接收到了事件\"+ value); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;);// 注：timer操作符默认运行在一个新线程上 interval( ) 作用 快速创建1个被观察者对象（Observable） 发送事件的特点：每隔指定时间 就发送 事件 发送的事件序列 = 从0开始、无限递增1的的整数序列 1234567891011121314151617181920212223242526// 参数说明：// 参数1 = 第1次延迟时间；// 参数2 = 间隔时间数字；// 参数3 = 时间单位；Observable.interval(3, 1, TimeUnit.SECONDS) // 该例子发送的事件序列特点：延迟3s后发送事件，每隔1秒产生1个数字（从0开始递增1，无限个） .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Long value) &#123; Log.d(\"TAG\", \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;);// 注：interval默认在computation调度器上执行 intervalRange( ) 作用 快速创建1个被观察者对象（Observable） 发送事件的特点：每隔指定时间 就发送 事件，可指定发送的数据的数量 发送的事件序列 = 从0开始、无限递增1的的整数序列作用类似于interval（），但可指定发送的数据的数量 1234567891011121314151617181920212223242526272829// 参数说明：// 参数1 = 事件序列起始点；// 参数2 = 事件数量；// 参数3 = 第1次事件延迟发送时间；// 参数4 = 间隔时间数字；// 参数5 = 时间单位Observable.intervalRange(3, 10, 2, 1, TimeUnit.SECONDS) // 该例子发送的事件序列特点： // 1. 从3开始，一共发送10个事件； // 2. 第1次延迟2s发送，之后每隔2秒产生1个数字（从0开始递增1，无限个） .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Long value) &#123; Log.d(\"TAG\", \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;); range( ) 作用 快速创建1个被观察者对象（Observable） 发送事件的特点：连续发送 1个事件序列，可指定范围 发送的事件序列 = 从0开始、无限递增1的的整数序列作用类似于intervalRange（），但区别在于：无延迟发送事件 12345678910111213141516171819202122232425// 参数说明：// 参数1 = 事件序列起始点；// 参数2 = 事件数量；// 注：若设置为负数，则会抛出异常Observable.range(3, 10) // 该例子发送的事件序列特点：从3开始发送，每次发送事件递增1，一共发送10个事件 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"TAG\", \"开始采用subscribe连接\"); &#125; // 默认最先调用复写的 onSubscribe（） @Override public void onNext(Integer value) &#123; Log.d(\"TAG\", \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"TAG\", \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(\"TAG\", \"对Complete事件作出响应\"); &#125; &#125;);"},{"title":"组合/合并操作符","date":"2018-05-24T15:04:44.000Z","updated":"2018-06-05T10:07:46.023Z","comments":true,"path":"rxjava3/index.html","permalink":"http://yoursite.com/rxjava3/index.html","excerpt":"","text":"组合多个被观察者concat( ) / concatArray( ) 作用组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 二者区别：组合被观察者的数量，即concat( )组合被观察者数量≤4个，而concatArray( )则可&gt;4个 123456789101112131415161718192021222324252627282930313233343536373839404142434445Observable.concat(Observable.just(1, 2, 3), Observable.just(4, 5, 6), Observable.just(7, 8, 9), Observable.just(10, 11, 12)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);// concatArray（）：组合多个被观察者一起发送数据（可&gt;4个）// 注：串行执行Observable.concatArray(Observable.just(1, 2, 3), Observable.just(4, 5, 6), Observable.just(7, 8, 9), Observable.just(10, 11, 12), Observable.just(13, 14, 15)) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); merge( ) / mergeArray( ) 作用组合多个被观察者一起发送数据，合并后 按时间线并行执行 二者区别：二者区别：组合被观察者的数量，即merge( )组合被观察者数量≤4个，而mergeArray( )则可&gt;4个区别上述concat( )操作符：同样是组合多个被观察者一起发送数据，但concat( )操作符合并后是按发送顺序串行执行 1234567891011121314151617181920212223// merge（）：组合多个被观察者（＜4个）一起发送数据// 注：合并后按照时间线并行执行Observable.merge( Observable.intervalRange(0, 3, 1, 1, TimeUnit.SECONDS), // 从0开始发送、共发送3个数据、第1次事件延迟发送时间 = 1s、间隔时间 = 1s Observable.intervalRange(2, 3, 1, 1, TimeUnit.SECONDS)) // 从2开始发送、共发送3个数据、第1次事件延迟发送时间 = 1s、间隔时间 = 1s .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);// mergeArray（） = 组合4个以上的被观察者一起发送数据，此处不作过多演示，类似concatArray（） concatDelayError( ) / mergeDelayError( ) 没啥用 合并多个事件Zip( ) 作用合并 多个被观察者（Observable）发送的事件，生成一个新的事件序列（即组合过后的事件序列），并最终发送 事件组合方式 = 严格按照原先事件序列 进行对位合并最终合并的事件数量 = 多个被观察者（Observable）中数量最少的数量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//创建第1个被观察者Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, \"被观察者1发送了事件1\"); emitter.onNext(1); // 为了方便展示效果，所以在发送事件后加入1s的延迟 Thread.sleep(1000); Log.d(TAG, \"被观察者1发送了事件2\"); emitter.onNext(2); Thread.sleep(1000); Log.d(TAG, \"被观察者1发送了事件3\"); emitter.onNext(3); Thread.sleep(1000); emitter.onComplete(); &#125;&#125;).subscribeOn(Schedulers.io()); // 设置被观察者1在工作线程1中工作//创建第2个被观察者Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; Log.d(TAG, \"被观察者2发送了事件A\"); emitter.onNext(\"A\"); Thread.sleep(1000); Log.d(TAG, \"被观察者2发送了事件B\"); emitter.onNext(\"B\"); Thread.sleep(1000); Log.d(TAG, \"被观察者2发送了事件C\"); emitter.onNext(\"C\"); Thread.sleep(1000); Log.d(TAG, \"被观察者2发送了事件D\"); emitter.onNext(\"D\"); Thread.sleep(1000); emitter.onComplete(); &#125;&#125;).subscribeOn(Schedulers.newThread());// 设置被观察者2在工作线程2中工作// 假设不作线程控制，则该两个被观察者会在同一个线程中工作，即发送事件存在先后顺序，而不是同时发送//使用zip变换操作符进行事件合并// 注：创建BiFunction对象传入的第3个参数 = 合并后数据的数据类型Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String string) throws Exception &#123; return integer + string; &#125;&#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"onSubscribe\"); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, \"最终接收到的事件 = \" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"onError\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125;&#125;); combineLatest( ) combineLatestDelayError( ) reduce( ) collect( ) 没啥用 发送事件前追加发送事件startWith( ) / startWithArray( ) 没啥用 统计发送事件数量没啥用"},{"title":"功能性操作符","date":"2018-05-24T16:54:47.000Z","updated":"2018-06-05T10:07:46.034Z","comments":true,"path":"rxjava4/index.html","permalink":"http://yoursite.com/rxjava4/index.html","excerpt":"","text":"连接被观察者 &amp; 观察者subscribe( ) 作用订阅，即连接观察者 &amp; 被观察者 简单，略过 线程调度subscribeOn( )指定 被观察者 (Observable) 的工作线程类型observeOn( )指定 被观察者观察者 (Observer) 的工作线程类型 类型 含义 应用场景 Schedulers.immediate() 当前线程 = 不指定线程 默认 AndroidSchedulers.mainThread() Android主线程 操作UI Schedulers.newThread() 常规新线程 耗时等操作 Schedulers.io() io操作线程 网络请求、读写文件等io密集型操作 Schedulers.computation() CPU计算操作线程 大量计算操作 延迟操作delay( ) 作用使得被观察者延迟一段时间再发送事件 12345678910111213141516171819Observable.just(1, 2, 3) .delay(3, TimeUnit.SECONDS) // 延迟3s再发送 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 在事件的生命周期中操作do( ) 没啥用 错误处理onErrorReturn( ) onErrorResumeNext( ) onExceptionResumeNext( ) 没啥用 retry( ) 作用重试，即当出现错误时，让被观察者（Observable）重新发射数据 接收到 onError（）时，重新订阅 &amp; 发送事件Throwable 和 Exception都可拦截 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onError(new Exception(\"发生错误了\")); e.onNext(3); &#125;&#125;) .retry(3) // 设置重试次数 = 3次 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); retryUntil( ) retryWhen( ) 重复发送repeat( ) 作用无条件地、重复发送 被观察者事件 具备重载方法，可设置重复创建次数 1234567891011121314151617181920Observable.just(1, 2, 3, 4) .repeat(3) // 重复创建次数 = 3次 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); repeatWhen( ) 没啥用"},{"title":"条件 / 布尔操作符","date":"2018-05-25T12:22:29.000Z","updated":"2018-06-05T10:07:46.049Z","comments":true,"path":"rxjava6/index.html","permalink":"http://yoursite.com/rxjava6/index.html","excerpt":"","text":"all( ) 作用判断发送的每项数据是否都满足 设置的函数条件 若满足，返回 true；否则，返回 false 12345678910111213Observable.just(1, 2, 3, 4, 5, 6) .all(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return (integer &lt;= 10); // 该函数用于判断Observable发送的10个数据是否都满足integer&lt;=10 &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"result is \" + aBoolean); &#125;&#125;); takeWhile( ) 作用判断发送的每项数据是否满足 设置函数条件 若发送的数据满足该条件，则发送该项数据；否则不发送 123456789101112131415161718192021222324// 1. 每1s发送1个数据 = 从0开始，递增1，即0、1、2、3Observable.interval(1, TimeUnit.SECONDS) // 2. 通过takeWhile传入一个判断条件 .takeWhile(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long integer) throws Exception &#123; return (integer &lt; 3); // 当发送的数据满足&lt;3时，才发送Observable的数据 &#125; &#125;).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, \"发送了事件 \" + value); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); skipWhile( ) 作用判断发送的每项数据是否满足 设置函数条件 直到该判断条件 = false时，才开始发送Observable的数据 123456789101112131415161718192021222324// 1. 每隔1s发送1个数据 = 从0开始，每次递增1Observable.interval(1, TimeUnit.SECONDS) // 2. 通过skipWhile（）设置判断条件 .skipWhile(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long aLong) throws Exception &#123; return (aLong &lt; 5); // 直到判断条件不成立 = false = 发射的数据≥5，才开始发送数据 &#125; &#125;).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, \"发送了事件 \" + value); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); takeUntil( ) 作用执行到某个条件时，停止发送事件 12345678910111213141516171819202122232425// 1. 每1s发送1个数据 = 从0开始，递增1，即0、1、2、3Observable.interval(1, TimeUnit.SECONDS) // 2. 通过takeUntil的Predicate传入判断条件 .takeUntil(new Predicate&lt;Long&gt;() &#123; @Override public boolean test(Long integer) throws Exception &#123; return (integer &gt; 3); // 返回true时，就停止发送事件 // 当发送的数据满足&gt;3时，就停止发送Observable的数据 &#125; &#125;).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, \"发送了事件 \" + value); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); skipUntil( ) 作用等到 skipUntil()传入的Observable开始发送数据，（原始）第1个Observable的数据才开始发送数据 12345678910111213141516171819202122// （原始）第1个Observable：每隔1s发送1个数据 = 从0开始，每次递增1Observable.interval(1, TimeUnit.SECONDS) // 第2个Observable：延迟5s后开始发送1个Long型数据 .skipUntil(Observable.timer(5, TimeUnit.SECONDS)) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Long value) &#123; Log.d(TAG, \"接收到了事件\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); SequenceEqual( ) 作用判定两个Observables需要发送的数据是否相同 若相同，返回 true；否则，返回 false 123456789Observable.sequenceEqual( Observable.just(4, 5, 6), Observable.just(4, 5, 6)).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"2个Observable是否相同：\" + aBoolean); &#125;&#125;); contains( ) 作用判断发送的数据中是否包含指定数据 若包含，返回 true；否则，返回 false内部实现 = exists（） 12345678Observable.just(1, 2, 3, 4, 5, 6) .contains(4) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"result is \" + aBoolean); &#125; &#125;); isEmpty( ) 作用判断发送的数据是否为空 若为空，返回 true；否则，返回 false 12345678Observable.just(1, 2, 3, 4, 5, 6) .isEmpty() // 判断发送的数据中是否为空 .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; Log.d(TAG, \"result is \" + aBoolean); &#125; &#125;); amb( ) 作用当需要发送多个 Observable时，只发送 先发送数据的Observable的数据，而其余 Observable则被丢弃。 123456789101112131415// 设置2个需要发送的Observable &amp; 放入到集合中List&lt;ObservableSource&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();// 第1个Observable延迟1秒发射数据list.add(Observable.just(1, 2, 3).delay(1, TimeUnit.SECONDS));// 第2个Observable正常发送数据list.add(Observable.just(4, 5, 6));// 一共需要发送2个Observable的数据// 但由于使用了amba（）,所以仅发送先发送数据的Observable// 即第二个（因为第1个延时了）Observable.amb(list).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e(TAG, \"接收到了事件 \" + integer); &#125;&#125;); defaultIfEmpty( ) 没啥用 总结"},{"title":"过滤操作符","date":"2018-05-24T19:21:22.000Z","updated":"2018-06-05T10:07:46.037Z","comments":true,"path":"rxjava5/index.html","permalink":"http://yoursite.com/rxjava5/index.html","excerpt":"","text":"根据 指定条件 过滤事件Filter( ) 作用过滤 特定条件的事件 1234567891011121314151617181920212223242526272829303132333435363738Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 发送5个事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); &#125; // 2. 采用filter（）变换操作符&#125;).filter(new Predicate&lt;Integer&gt;() &#123; // 根据test()的返回值 对被观察者发送的事件进行过滤 &amp; 筛选 // a. 返回true，则继续发送 // b. 返回false，则不发送（即过滤） @Override public boolean test(Integer integer) throws Exception &#123; return integer &gt; 3; // 本例子 = 过滤了整数≤3的事件 &#125;&#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"过滤后得到的事件是：\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125;&#125;); ofType( ) 作用过滤 特定数据类型的数据 12345678Observable.just(1, \"Carson\", 3, \"Ho\", 5) .ofType(Integer.class) // 筛选出 整型数据 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的整型事件元素是： \" + integer); &#125; &#125;); skip( ) / skipLast( ) 作用跳过某个事件 123456789101112131415161718192021// 使用1：根据顺序跳过数据项Observable.just(1, 2, 3, 4, 5) .skip(1) // 跳过正序的前1项 .skipLast(2) // 跳过正序的后2项 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的整型事件元素是： \" + integer); &#125; &#125;);// 使用2：根据时间跳过数据项// 发送事件特点：发送数据0-5，每隔1s发送一次，每次递增1；第1次发送延迟0sObservable.intervalRange(0, 5, 0, 1, TimeUnit.SECONDS) .skip(1, TimeUnit.SECONDS) // 跳过第1s发送的数据 .skipLast(1, TimeUnit.SECONDS) // 跳过最后1s发送的数据 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long along) throws Exception &#123; Log.d(TAG, \"获取到的整型事件元素是： \" + along); &#125; &#125;); distinct( ) / distinctUntilChanged( ) 作用过滤事件序列中重复的事件 / 连续重复的事件 12345678910111213141516171819// 使用1：过滤事件序列中重复的事件Observable.just(1, 2, 3, 1, 2) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"不重复的整型事件元素是： \" + integer); &#125; &#125;);// 使用2：过滤事件序列中 连续重复的事件// 下面序列中，连续重复的事件 = 3、4Observable.just(1, 2, 3, 1, 2, 3, 3, 4, 4) .distinctUntilChanged() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"不连续重复的整型事件元素是： \" + integer); &#125; &#125;); 根据 指定事件数量 过滤事件take( ) 作用指定观察者最多能接收到的事件数量 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 1. 发送5个事件 emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onNext(4); emitter.onNext(5); &#125; // 采用take（）变换操作符 // 指定了观察者只能接收2个事件&#125;).take(2) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"过滤后得到的事件是：\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;);// 实际上，可理解为：被观察者还是发送了5个事件，只是因为操作符的存在拦截了3个事件，最终观察者接收到的是2个事件 takeLast( ) 作用指定观察者只能接收到被观察者发送的最后几个事件 1234567891011121314151617181920Observable.just(1, 2, 3, 4, 5) .takeLast(3) //指定观察者只能接受被观察者发送的3个事件 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, \"开始采用subscribe连接\"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, \"过滤后得到的事件是：\" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, \"对Error事件作出响应\"); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"对Complete事件作出响应\"); &#125; &#125;); 根据 指定时间 过滤事件distinct( ) / distinctUntilChanged( ) 作用在某段时间内，只发送该段时间内第1次事件 / 最后1次事件 Sample( ) 作用在某段时间内，只发送该段时间内最新（最后）1次事件 distinct( ) / distinctUntilChanged( ) 作用发送数据事件时，若2次发送事件的间隔＜指定时间，就会丢弃前一次的数据，直到指定时间内都没有新数据发射时才会发送后一次的数据 没啥用 根据 指定事件位置 过滤事件firstElement( ) / lastElement( ) 作用仅选取第1个元素 / 最后一个元素 123456789101112131415161718// 获取第1个元素Observable.just(1, 2, 3, 4, 5) .firstElement() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的第一个事件是： \" + integer); &#125; &#125;);// 获取最后1个元素Observable.just(1, 2, 3, 4, 5) .lastElement() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的最后1个事件是： \" + integer); &#125; &#125;); elementAt( ) 作用指定接收某个元素（通过 索引值 确定） 注：允许越界，即获取的位置索引 ＞ 发送事件序列长度 12345678910111213141516171819// 使用1：获取位置索引 = 2的 元素// 位置索引从0开始Observable.just(1, 2, 3, 4, 5) .elementAt(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的事件元素是： \" + integer); &#125; &#125;);// 使用2：获取的位置索引 ＞ 发送事件序列长度时，设置默认参数Observable.just(1, 2, 3, 4, 5) .elementAt(6, 10) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, \"获取到的事件元素是： \" + integer); &#125; &#125;); elementAtOrError( ) 作用在elementAt（）的基础上，当出现越界情况（即获取的位置索引 &gt; 发送事件序列长度）时，即抛出异常 没啥用 总结"},{"title":"Tags","date":"2018-06-05T10:07:46.062Z","updated":"2018-06-05T10:07:46.062Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"V1、V2签名包和快速集成美团多渠道打包","slug":"V1、V2签名包和快速集成美团多渠道打包","date":"2018-05-18T12:00:10.000Z","updated":"2018-06-05T10:07:45.954Z","comments":true,"path":"2018/05/18/V1、V2签名包和快速集成美团多渠道打包/","link":"","permalink":"http://yoursite.com/2018/05/18/V1、V2签名包和快速集成美团多渠道打包/","excerpt":"","text":"本文主要介绍Android V1、V2签名包的基本概念和使用场景以及如何快速掌握美团多渠道打包。 美团多渠道打包的快速使用和集成 Android Studio 2.3版本及以上，V1、V2版本签名包的相关说明 V1、V2版本签名包的比较以及在本文提供的多渠道打包方案下，两种签名包的选择 开始 首先下载美团打包工具，下载完毕以后，解压出来会有2个包，一个是Python的安装环境，一个是美团打包的工具。其中，美团的打包工具是一个压缩包，解压之后，有如下文件。 下载无误之后，即可开始快速集成美团多渠道集成步骤： 步骤1：配置Python环境 这里就不讲解了，到python官网上下载最新的python安装包然后安装就行了 步骤2： 集成好Python的环境配置以后，打开下载好的美团打包工具。也就是本文第一张图，首先，有一个JavaUtil，这个是获取渠道信息的代码（可以自己Copy到项目，根据项目需求去集成使用）；还有一个PythonTool文件夹，这个就是美团打包的核心，点进这个文件夹之后，如图： 我们只需要把生成好的正式签名包，copy在这里。（这里只是演示，也就是app-release.apk这个文件）我们只需要把写好的正式签名包，copy在这里。注意：必须是同级目录。 然后，点击MultiChannelBuildTool这个python文件，点击一下即可！ 点击之后，会生成一个紫色框的文件夹，我们点进去该文件夹 一瞬间生成了这么多个apk,耗时半秒不到。 基本的多渠道打包使用就已经完成了。 十分钟不到吧应该。是的，已经打包完毕了。 问题1：如何配置其他的渠道？ info文件夹，目录下的channel就是用来存放打包渠道的，注意：多个渠道之间请用换行隔开、多个渠道之间请用换行隔开（不建议使用Windows下面的txt直接打开，强烈建议使用notepad++等第三方文字编辑工具使用编辑！！！） 问题2：如何获取渠道信息？ 在前面说到了，给大家准备的下载链接里面，解压缩后有个JavaUtil的包，这里面就是获取渠道信息的代码，开发者可以根据这个工具类，去获取渠道号。或者根据开发需要自己集成使用即可。 关于V1、V2签名包的说明： 说完了美团多渠道打包，我们在说说V1、V2签名包。 如果我们升级到最新的AS（笔者的是3.0），点击打包选项，细心的你会看到这样的打包界面： 老版本的AS，只有V1选择，也就是紫色的框框。但是新版本的AS，默认勾选的是V2版本（笔者的AS默认是勾选的V2版本）。如果只勾选V2版本，打出来的签名包，很多机型会直接提示安装失败。解决办法下面会说。 概述： 在Android 7.0中引入了APK Signature Scheme v2，v1是jar Signature来自JDK。 V1：应该是通过ZIP条目进行验证，这样APK 签署后可进行许多修改，这样可以移动甚至重新压缩文件。 V2：验证压缩文件的所有字节，而不是单个 ZIP 条目，因此，在签名后无法再更改(包括 zipalign)。正因如此，现在在编译过程中，我们将压缩、调整和签署合并成一步完成。好处显而易见，更安全而且新的签名可缩短在设备上进行验证的时间（不需要费时地解压缩然后验证），从而加快应用安装速度。 刚才说了，如果只勾选V2版本，打出来的签名包，很多机型会直接提示安装失败。下面就给大家提供两种解决方案 解决方案一： V1和V2的签名使用： 1）只勾选V1签名并不会影响什么，但是在7.0上不会使用更安全的验证方式 2）只勾选V2签名7.0以下会直接安装完显示未安装，7.0以上则使用了V2的方式验证 3）同时勾选V1和V2则所有机型都没问题。 解决办法二： 还有一种快速高效的代码解决方式，我们可以直接在app的build.gradle的android标签下，加入以下代码也可以解决只勾选V2版本签名包部分机型会提示安装失败的问题。 V2签名包是从Android7.0系统出现的新的签名机制，这个新机制使得apk的签名方式更加安全。首先我们应该尝试把V1和V2两个选项全部勾选，并尽可能的去使用他们，但是如果全部勾选完毕出现了问题，那么我们可以忽略这种新的签名机制，只勾选第一个选项(V1)，依旧使用我们之前老的签名机制，也就是说，V1版本更加快速方便。 为什么这里会提到V1、V2的区别。因为这里的美团多渠道打包只能适用于V1版本的签名包，MMP 所以，个人还是推荐使用V1打包方式。因为稳定，所以放心。","categories":[],"tags":[{"name":"打包","slug":"打包","permalink":"http://yoursite.com/tags/打包/"}]},{"title":"apk瘦身","slug":"apk瘦身","date":"2018-05-02T11:24:49.000Z","updated":"2018-06-05T10:07:45.960Z","comments":true,"path":"2018/05/02/apk瘦身/","link":"","permalink":"http://yoursite.com/2018/05/02/apk瘦身/","excerpt":"","text":"代码混淆主流开源项目的混淆规则列表https://github.com/krschultz/android-proguard-snippets Android Studio → Analyze → Inspect Code删掉无用的代码和图片 使用tinypng、智图等图片压缩工具对图片进行压缩https://tinypng.com/http://zhitu.isux.us/ 资源文件混淆介绍：http://www.tuicool.com/articles/qMVbIbigithub：https://github.com/shwenzhang/AndResGuard 字体文件压缩github：https://github.com/forJrking/FontZip 减少第三库的使用 使用9.png图上跟左，表示拉伸；右跟下，表示内容范围 用代码代替图片shape代替圆形 用RotateDrawable代替仅仅是方向不同的“内容相同”的图片 这里两个图片是两个按钮箭头，但是仅仅方向不同而已，其实可以只用其中一个图片即可，而另一个用RotateDrawable来让其“调转”180度 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@drawable/ic_arrow_left\" android:fromDegrees=\"180\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:toDegrees=\"180\" /&gt; 用layer-list来制作多层图片从而达到复用有些需求中需要一种图片，但是明显这个图片是其他几个图片简单叠加而已，那么可以使用layer-list来达到目的 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item&gt; &lt;!-- 最底层的图片，以x，y轴坐标为中心进行旋转--&gt; &lt;rotate android:pivotX=\"0\" android:pivotY=\"0\" android:fromDegrees=\"-10\" android:toDegrees=\"-10\"&gt; &lt;bitmap android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/rotate&gt; &lt;/item&gt; &lt;!-- 第二层的图片，以x，y轴坐标为中心进行旋转--&gt; &lt;item&gt; &lt;rotate android:pivotX=\"0\" android:pivotY=\"0\" android:fromDegrees=\"15\" android:toDegrees=\"15\"&gt; &lt;bitmap android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/rotate&gt; &lt;/item&gt; &lt;!-- 最上层的图片，以x，y轴坐标为中心进行旋转--&gt; &lt;item&gt; &lt;rotate android:pivotX=\"0\" android:pivotY=\"0\" android:fromDegrees=\"35\" android:toDegrees=\"55\"&gt; &lt;bitmap android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/rotate&gt; &lt;/item&gt;&lt;/layer-list&gt; 通过配置resConfig可以选择只打包哪几种语言，如果只保留默认英语和中文语言，配置如下 12345android&#123; defaultConfig&#123; resConfigs \"zh\", \"en\" &#125;&#125; 谷歌redex对字节码进行优化https://github.com/facebook/redex.git 避免枚举一个枚举可以为您的应用程序的classes.dex文件添加大约1.0到1.4 KB的大小。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"程序员英语口语等级考试","slug":"程序员英语口语等级考试","date":"2018-05-02T11:17:25.000Z","updated":"2018-06-05T10:07:45.972Z","comments":true,"path":"2018/05/02/程序员英语口语等级考试/","link":"","permalink":"http://yoursite.com/2018/05/02/程序员英语口语等级考试/","excerpt":"","text":"这个世界上有四种英语——美式英语、英式英语、中国式英语，还有一个程序员英语！程序员英语有个特点，那就是不同公司、不同大会，对同一个单词，可能都有多种不同的读法，与编辑器圣战、IDE圣战、终端圣战一样，也许你也有曾经看不惯他人的发音，下面就来个小测试吧，看看你在圣战中，到底站在哪一方！注意，文中给出的中文标注仅用来区分大致的发音，具体的发音已音标为准 发音练习之初级篇App[ˈæp]，跟我读『爱普』，不是『爱屁屁』啊Java[ˈdʒɑːvə]，跟我读『扎哇』，不是『夹娃』啊Chrome[krəʊm]，跟我读『克弱姆』啊Adobe[əˈdəʊbi]，跟我读『额刀比』啊Skype[ˈskaɪp]，跟我读『死盖破』，不是『死盖屁』啊YoutubeYou-tube [tju:b]，跟我读『优tiu波』，不是『优土比』啊Ubuntu[uˈbuntuː]，跟我读『乌班图』，不是『优班图』啊 发言联系之高级篇jpg[ˈdʒeɪpɛɡ]，跟我读『杰派哥』啊Null[nʌl]，跟我读『闹』，不是『努努』（我知道你日语好）Cache[kæʃ]，跟我读『凯西』，不是『卡车』啊Mac OS XX不是『艾克斯』啊，是罗马数字十！所以要读『Mac OS Ten』啊Ajax[‘eidʒæks]，跟我读『诶贾克斯』，不是『阿贾克斯』啊Icon跟我读『爱康』，不是『爱啃』啊Angular[‘æŋgjʊlə]，跟我读『安古拉』，不是『安哥拉』啊Issue[‘ɪʃuː]，跟我读『衣休』，不是『唉休』啊Module[‘mɒdjuːl]，跟我读『幕久』，不是『幕抖』啊Maven[‘meɪvn]，跟我读『梅文』，不是『马文』啊Django跟我读『江狗』，不是『大江狗』啊","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"Android运行时权限详解","slug":"Android运行时权限详解","date":"2018-01-11T12:38:09.000Z","updated":"2018-06-05T10:07:45.952Z","comments":true,"path":"2018/01/11/Android运行时权限详解/","link":"","permalink":"http://yoursite.com/2018/01/11/Android运行时权限详解/","excerpt":"","text":"Android系统权限Android 是一个权限分隔的操作系统，其中每个应用都有其独特的系统标识（Linux 用户 ID 和组 ID）。系统各部分也分隔为不同的标识。Linux 据此将不同的应用以及应用与系统分隔开来。在默认情况下任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用程序的文件、执行网络访问、使设备保持唤醒状态等。 在旧的权限管理系统中，权限仅仅在App安装时询问用户一次，用户同意了这些权限App才能被安装，App一旦安装后后授权不可取消。 Android6.0引入了新的权限模式，将系统权限区分为正常权限和危险权限。开发者在使用到危险权限相关的功能时，不仅需要在Manifest文件中配置，还需要在代码中动态获取权限，如果没有确认获取到权限而直接执行相应所需权限的代码，将导致App崩溃。另外，Android6.0 以上系统,App 退到后台，修改应用权限，再次 App 回到前台，会出现应用新开进程重启。 权限的使用Android App 默认无任何权限，如果需要使用系统权限必须在AndroidManifest.xml文件中声明权限。1234567891011//声明网络使用权限&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.permission\"&gt;&lt;uses-permission android:name=\"android.permission.INTERNE\"/&gt; &lt;application ...&gt; ...&lt;/application&gt;&lt;/manifest&gt; 如果所需权限为正常权限（即不会对用户隐私或设备操作造成很大风险的权限），系统会自动授予这些权限。 如果所需权限为危险权限（即可能影响用户隐私或设备正常操作的权限），系统会要求用户明确授予这些权限。Android 发出请求的方式取决于系统版本(即targetSdkVersion)： 如果运行在 Android 6.0 及以上版本，App targetSdkVersion 大于23，则需要在运行时向用户请求权限，并且需要在 App 使用相关的权限之前检查自身是否已被授予该权限。 如果运行在 Android 6.0 以下版本，或App targetSdkVersion 小于23（此时设备可以是Android 6.0 (API level 23)或者更高），则系统会在用户安装则系统会在用户安装App时要求用户授予权限，系统就告诉用户App需要什么权限组。如果App将新权限添加到更新的应用版本，系统会在用户更新应用时要求授予该权限。用户一旦安装应用，他们撤销权限的唯一方式是卸载应用。正常权限正常权限涵盖应用需要访问其沙盒外部数据或资源，但对用户隐私或其他应用操作风险很小的区域。例如，设置时区的权限就是正常权限。此类权限都是正常保护的权限，只需要在Manifest文件中简单声明，安装即授权。 ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR UNINSTALL_SHORTCUT USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS危险权限 危险权限涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。例如，能够读取用户的联系人属于危险权限。 CALENDAR READ_CALENDAR WRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATE READ_PHONE_NUMBERS CALL_PHONE ANSWER_PHONE_CALLS (must request at runtime) READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS STORAGE READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 特殊权限有许多权限其行为方式与正常权限及危险权限都不同。SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 特别敏感，因此大多数应用不应该使用它们。如果某应用需要其中一种权限，必须在清单中声明该权限，并且发送请求用户授权的 intent。系统将向用户显示详细信息，以响应该 intent。 权限组所有危险权限都拥有对应权限组，如果运行在 Android 6.0 及以上版本，App targetSdkVersion 大于23，则当用户请求危险权限时系统会发生以下行为： 如果应用未拥有Manifest列出的危险权限所在的权限组任一权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用已拥有Manifest列出的危险权限所在的权限组其他任一权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 Android O的运行时权限策略变化 在 Android O 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。 我们申请了WRITE_EXTERNAL_STORAGE权限，在Android O之前，我们同时会得到READ_EXTERNAL_STORAGE权限，我们在其它地方涉及到读取存储卡的操作时只需要判断有WRITE_EXTERNAL_STORAGE权限就去读取了。此时应用如果安装在Android O的系统中我们会发现，判断了有WRITE_EXTERNAL_STORAGE权限后去读取存储卡内容时应用崩溃了，原因就是我们没有申请READ_EXTERNAL_STORAGE权限。 运行时请求权限检查权限及兼容(1)对于运行在 Android 6.0及以上 App targetSdkVersion 大于23的应用 如果App需要用到危险权限，需要这一权限的操作时都必须检查自己是否拥有该权限。 1int permissionCheck = ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.WRITE_CALENDAR); 如果应用已经具有了该权限,此方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，此时应用应当进行权限申请。 (2)对于运行在 Android 6.0及以上 App targetSdkVersion 大于23的应用 在App安装时会询问AndroidManifest.xml文件中的权限,用户也可以在设置列表中手动关闭/开启相关权限。 (3)对于运行在 Android 6.0以下 App targetSdkVersion 大于23的应用 对于运行在 Android 6.0以下 App targetSdkVersion 大于23的应用，默认情况下是会采取旧的权限机制，然而，一些国产手机在6.0之前就引入了权限管理系统，所以必须对其进行兼容。 下面我们来看ActivityCompat.requestPermissions()方法。 12345678910111213141516171819202122232425public static void requestPermissions(final @NonNull Activity activity, final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode) &#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; ActivityCompatApi23.requestPermissions(activity, permissions, requestCode); &#125; else if (activity instanceof OnRequestPermissionsResultCallback) &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; final int[] grantResults = new int[permissions.length]; PackageManager packageManager = activity.getPackageManager(); String packageName = activity.getPackageName(); final int permissionCount = permissions.length; for (int i = 0; i &lt; permissionCount; i++) &#123; grantResults[i] = packageManager.checkPermission( permissions[i], packageName); &#125; ((OnRequestPermissionsResultCallback) activity).onRequestPermissionsResult( requestCode, permissions, grantResults); &#125; &#125;); &#125;&#125; 系统版本小于23时，使用packageManager.checkPermission()对权限进行校验，而当App在AndroidManifest.xml中声明权限时，会返回PERMISSION_GRANTED，显然，这一校验方法在Android 6.0以下将失效。 PermissionChecker.checkSelfPermission()PermissionChecker是 Support V4 包下一个专门检查权限的工具类 123456789101112131415161718192021222324public static int checkPermission(@NonNull Context context, @NonNull String permission, int pid, int uid, String packageName) &#123; if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) &#123; return PERMISSION_DENIED; &#125; String op = AppOpsManagerCompat.permissionToOp(permission); if (op == null) &#123; return PERMISSION_GRANTED; &#125; if (packageName == null) &#123; String[] packageNames = context.getPackageManager().getPackagesForUid(uid); if (packageNames == null || packageNames.length &lt;= 0) &#123; return PERMISSION_DENIED; &#125; packageName = packageNames[0]; &#125; if (AppOpsManagerCompat.noteProxyOp(context, op, packageName) != AppOpsManagerCompat.MODE_ALLOWED) &#123; return PERMISSION_DENIED_APP_OP; &#125; return PERMISSION_GRANTED;&#125; checkSelfPermission通过上述四个判断语句进行权限校验 context.checkPermission()实际上调用的还是上述packageManager.checkPermission()方法进行校验。 AppOpsManagerCompat.permissionToOp()调用了IMPL.permissionToOp(permission)方法 12345678private static final AppOpsManagerImpl IMPL;static &#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; IMPL = new AppOpsManager23(); &#125; else &#123; IMPL = new AppOpsManagerImpl(); &#125;&#125; 可以看到，在Android6.0以下设备中，会使用AppOpsManagerImpl,其permissionToOp()方法进行权限检查，其默认返回null,所以PermissionChecker.checkSelfPermission() 同样会失效。 12345678910111213141516private static class AppOpsManagerImpl &#123; AppOpsManagerImpl() &#123; &#125; public String permissionToOp(String permission) &#123; return null; &#125; public int noteOp(Context context, String op, int uid, String packageName) &#123; return MODE_IGNORED; &#125; public int noteProxyOp(Context context, String op, String proxiedPackageName) &#123; return MODE_IGNORED; &#125;&#125; 此外，Google官方还提供了AppOpsManager类来检查权限 12345678910111213141516public int checkOp(String op, int uid, String packageName) &#123; return checkOp(strOpToOp(op), uid, packageName);&#125;@hide public int checkOp(int op, int uid, String packageName) &#123; try &#123; int mode = mService.checkOperation(op, uid, packageName); if (mode == MODE_ERRORED) &#123; throw new SecurityException(buildSecurityExceptionMsg(op, uid, packageName)); &#125; return mode; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 为了更好的兼容不同厂家的国产手机,建议针对不同的系统版本使用不同的权限校验策略，对于 Android 6.0以上设备，使用PermissionChecker.checkSelfPermission()进行权限校验，对于Android 6.0 以下设备，可通过触发try catch后的危险权限代码检查是否有权限，以期准确校验权限，对用户进行引导，具体可参考AndPermission等第三方库。 请求权限对于App targetSdkVersion 大于23的应用，在应用需要使用的危险权限，必须要进行动态权限申请。Android 提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框。 调用requestPermissions() 方法，可进行动态权限申请，该方法是异步的。在用户响应对话框之后，系统会回调onRequestPermissionsResult。12345678910if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; &#125; else &#123; ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); &#125;&#125; 处理权限请求回调在用户响应对话框之后，系统会回调 onRequestPermissionsResult() 方法。 123456789101112131415@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; &#125; else &#123; &#125; return; &#125; &#125;&#125; 权限申请被拒绝如果用户拒绝了某项权限请求，应用应采取适当的操作进行引导，应用应当显示一个对话框，解释应用为什么需要此权限，以及使用该权限有何影响。 当系统要求用户授予权限时，用户可以选择指统不再要求提供该权限。这种情况下，无论应用在什么时候使用 requestPermissions() 请求该权限，系统都会立即拒绝此请求。系统会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED，如果用户再次明确拒绝了权限的请求，系统将采用相同方式操作。这意味着当调用 requestPermissions()时，不一定会出现系统权限请求弹窗。 此时可借助shouldShowRequestPermissionRationale()这个回调方法，如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。如果用户拒绝了权限请求，并在权限请求系统对话框中选择了不再询问选项，此方法将返回 false。如果设备默认禁止应用具有该权限，此方法也会返回 false。 shouldShowRequestPermissionRationale() 望文生义，是否应该显示请求权限的说明。 第一次请求权限时，用户拒绝了，调用shouldShowRequestPermissionRationale()后返回true，应该显示一些为什么需要这个权限的说明。 用户在第一次拒绝某个权限后，下次再次申请时，授权的dialog中将会出现“不再提醒”选项，一旦选中勾选了，那么下次申请将不会提示用户。 第二次请求权限时，用户拒绝了，并选择了“不再提醒”的选项，调用shouldShowRequestPermissionRationale()后返回false。 设备的策略禁止当前应用获取这个权限的授权：shouldShowRequestPermissionRationale()返回false 。 加这个提醒的好处在于，用户拒绝过一次权限后我们再次申请时可以提醒该权限的重要性，免得再次申请时用户勾选“不再提醒”并决绝，导致下次申请权限直接失败。 关于运行时权限的一些建议(1)只请求需要的权限，减少请求的次数，或用隐式Intent来让其他的应用来处理。 使用Intent，你不需要设计界面，由第三方的应用来完成所有操作。比如打电话、选择图片等。 如果请求权限，你可以完全控制用户体验，自己定义UI。但是用户也可以拒绝权限，就意味着你的应用不能执行这个特殊操作。 (2)防止一次请求太多的权限或请求次数太多，用户可能对你的应用感到厌烦，在应用启动的时候，最好先请求应用必须的一些权限，非必须权限在使用的时候才请求，建议整理并按照上述分类管理自己的权限： 普通权限（Normal PNermissions）：只需要在Androidmanifest.xml中声明相应的权限，安装即许可。 需要运行时申请的权限（Dangerous Permissions）： 必要权限：最好在应用启动的时候，进行请求许可的一些权限（主要是应用中主要功能需要的权限）。 附带权限：不是应用主要功能需要的权限(如：选择图片时，需要读取SD卡权限)。 解释你的应用为什么需要这些权限：在你调用requestPermissions()之前，你为什么需要这个权限。例如，一个摄影的App可能需要使用定位服务，因为它需要用位置标记照片。一般的用户可能会不理解，他们会困惑为什么他们的App想要知道他的位置。所以在这种情况下，所以你需要在requestpermissions()之前告诉用户你为什么需要这个权限。 (3)使用兼容库support-v4中的方法 PermissionChecker.checkSelfPermission() 或者 ContextCompat.checkSelfPermission() ActivityCompat.requestPermissions() ActivityCompat.shouldShowRequestPermissionRationale() 国产机权限问题整理 部分中国厂商生产手机（例如小米）的Rationale功能，在第一次拒绝后，第二次申请时不会返回true，并且会回调申请失败，也就是说在第一次拒绝后默认勾选了不再提示。 部分中国厂商生产手机（例如小米、华为）在申请权限时，用户点击确定授权后，还是回调我们申请失败，这个时候其实我们是拥有权限的，所以我们可以在失败的方法中使用AppOpsManager进行权限判断。 部分中国厂商生产手机（例如vivo、Oppo）在用户允许权限，并且回调了权限授权成功的方法，但是实际执行代码时并没有这个权限，建议开发者在回调成功的方法中也利用AppOpsManager判断下。 在某些手机的Setting中授权后实际检查时还是没有权限，部分执行代码也是没有权限。 从系统版本看国产机型的权限申请特点 5.0：此时 google 还未着手处理动态权限申请这么个东西，但是我们的小米、魅族等厂商就开始提前设置了强大的权限管理，所以 6.0 权限申请代码在 5.0 上压根不管用，但是说来也简单，5.0 的权限申请对话框激活就是靠触发危险权限代码，然后根据返回值来判断权限是否获取到了（不同手机的返回值判断方式不同，此处需要一一定制）。 6.0：国产大部分机型手机的申请权限实际上应该细致地分为申请权限和应用权限 。它们的 ContextCompat.checkSelfPermission(Context, String) 判断是根据是否 AndroidManifest.xml 中声明了该权限来决定返回值，在 AndroidManifest.xml 中声明了权限就返回 true，当然也会有一些会返回 false，这个是申请权限的过程。而真正对话框的弹出是在开发者应用权限的过程中，什么叫做应用权限？就是调用了会触发权限的代码，这个时候就会激活对话框，但是如果仅到这里那就 too young too simple 了，当用户点击拒绝授权时，还是可能会回调授权成功的方法。另外，国产机大部分权限是有三个状态——询问、允许、拒绝——大部分权限都是询问状态，但是有些权限默认是允许状态，有些是拒绝状态，这就导致了调用 ContextCompat.checkSelfPermission(Context, String) 方法时会更畸形，例如小米手机的获取 READ_PHONE_STATE 状态，默认是授予状态。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"Android混淆总结","slug":"Android混淆总结","date":"2017-12-23T19:27:42.000Z","updated":"2018-06-05T10:07:45.935Z","comments":true,"path":"2017/12/24/Android混淆总结/","link":"","permalink":"http://yoursite.com/2017/12/24/Android混淆总结/","excerpt":"","text":"通过代码混淆可以将项目中的类、方法、变量等信息进行重命名，变成一些无意义的简短名字，同时也可以移除未被使用的类、方法、变量等。所以直观的看，通过混淆可以提高程序的安全性，增加逆向工程的难度，同时也有效缩减了apk的体积。 开启混淆在基于Android Studio项目的app module的build.gradle中有如下默认代码片段： 1234567buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; minifyEnabled true 代表要发布的release包的混淆配置，默认不开启混淆，设为true表示开启混淆。 shrinkResources true 代表开启资源文件压缩。 proguard-android.txt 代表系统默认的混淆规则配置文件，该文件在/tools/proguard下，一般不要更改该配置文件。 proguard-rules.pro 代表当前module的混淆配置文件，可以通过修改该文件来添加当前项目的混淆规则。 编写混淆配置文件以下是系统的proguard-android.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html# 混淆时不使用大小写混合类名-dontusemixedcaseclassnames# 不跳过library中的非public的类-dontskipnonpubliclibraryclasses# 打印混淆的详细信息-verbose# Optimization is turned off by default. Dex does not like code run# through the ProGuard optimize and preverify steps (and performs some# of these optimizations on its own).# 关闭优化（原因见上边的原英文注释）-dontoptimize# 不进行预校验，可加快混淆速度-dontpreverify# Note that if you want to enable optimization, you cannot just# include optimization flags in your own project configuration file;# instead you will need to point to the# \"proguard-android-optimize.txt\" file instead of this one from your# project.properties file.# 保留注解中的参数-keepattributes *Annotation*# 不混淆如下两个谷歌服务类-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# For native methods, see http://proguard.sourceforge.net/manual/examples.html#native# 不混淆包含native方法的类的类名以及native方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# keep setters in Views so that animations can still work.# see http://proguard.sourceforge.net/manual/examples.html#beans# 不混淆View中的setXxx()和getXxx()方法，以保证属性动画正常工作-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;# We want to keep methods in Activity that could be used in the XML attribute onClick# 不混淆Activity中参数是View的方法，例如，一个控件通过android:onClick=\"clickMethodName\"绑定点击事件，混淆后会导致点击事件失效-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations# 不混淆枚举类中的values()和valueOf()方法-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 不混淆Parcelable实现类中的CREATOR字段，以保证Parcelable机制正常工作-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;# 不混淆R文件中的所有静态字段，以保证正确找到每个资源的id-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# The support library contains references to newer platform versions.# Don't warn about those in case this app is linking against an older# platform version. We know about them, and they are safe.# 不对android.support包下的代码警告（如果我们打包的版本低于support包下某些类的使用版本，会出现警告的问题）-dontwarn android.support.**# Understand the @Keep support annotation.# 不混淆Keep类-keep class android.support.annotation.Keep# 不混淆使用了注解的类及类成员-keep @android.support.annotation.Keep class * &#123;*;&#125;# 如果类中有使用了注解的方法，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;# 如果类中有使用了注解的字段，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;# 如果类中有使用了注解的构造函数，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; keep关键字： 关键字 含义 keep 保留类和类成员，防止被混淆或移除 keepnames 保留类和类成员，防止被混淆，但没有被引用的类成员会被移除 keepclassmembers 只保留类成员，防止被混淆或移除 keepclassmembernames 只保留类成员，防止被混淆，但没有被引用的成员会被移除 keepclasseswithmembers 保留类和类成员，防止被混淆或移除，如果指定的类成员不存在还是会被混淆 keepclasseswithmembernames 保留类和类成员，防止被混淆，如果指定的类成员不存在还是会被混淆，没有被引用的类成员会被移除 相关通配符： 通配符 含义 * 匹配任意长度字符，但不含包名分隔符.。例如一个类的全包名路径是com.othershe.test.Person，使用com.othershe.test.、com.othershe.test.都是可以匹配的，但com.othershe.*就不能匹配 ** 匹配任意长度字符，并包含包名分隔符.。例如要匹配com.othershe.test.**包下的所有内容 * 匹配任意参数类型。例如 getName()可匹配String getName(String) … 匹配任意长度的任意类型参数。例如void setName(…)可匹配void setName(String firstName, String secondName) &lt;fileds&gt; 匹配类、接口中所有字段 &lt;methods&gt; 匹配类、接口中所有方法 &lt;init&gt; 匹配类中所有构造函数 以上就是混淆的基本语法，系统的proguard-android.txt已经为我们完成了大部分基础的混淆配置工作，至于编写当前app module下的proguard-rules.pro，只需要针对当前项目添加一些特有的配置，避免某些重要的东西被混淆掉就可以了，我们主要考虑以下几点： 在AndroidManifest.xml中注册的继承四大组件的子类的类名以及重写的方法名都不会被混淆。 比如，如果希望项目中android.support.v4.app.Fragment子类的类名和重写父类的方法名不被混淆可以添加如下配置12345# 不混淆Fragment的子类类名以及onCreate()、onCreateView()方法名-keep public class * extends android.support.v4.app.Fragment &#123; public void onCreate(android.os.Bundle); public android.view.View onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle);&#125; 不混淆某个特定的类和类中所有成员 1-keep class com.test.utils.CommonUtil &#123; *; &#125; 不混淆某个目录下的文件，例如使用Gson时，数据bean不能被混淆，需要如下配置： 12# com.test.bean代表所有bean所在的目录-keep class com.test.bean.** &#123; *; &#125; 保留泛型 1-keepattributes Signature 保留用于调试堆栈跟踪的行号信息 1-keepattributes SourceFile,LineNumberTable WebView中使用了JS调用，需要添加如下配置： 123-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125; 项目中使用的第三方库的混淆规则，这里列举几个常用的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# okhttp-dontwarn okhttp3.**-dontwarn okio.**-dontwarn javax.annotation.**-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase# Retrofit-dontwarn okio.**-dontwarn javax.annotation.**-dontnote retrofit2.Platform-dontwarn retrofit2.Platform$Java8-keepattributes Signature-keepattributes Exceptions# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Gson-keep class com.google.gson.stream.** &#123; *; &#125;-keepattributes EnclosingMethod# xxx代表model类的全包名路径-keep class xxx.** &#123; *; &#125;# butterknie-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# eventbus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; 查看混淆结果混淆后打包，会在app module/build/outputs/mapping/release目录下生成如下文件 dump.txt：描述apk文件中所有类的内部结构 mapping.txt：混淆前后的类、类成员、方法的对照关系（重要，追溯Crash堆栈信息要用到） resources.txt：资源文件的压缩信息 seeds.txt：未被混淆的类和成员 usage.txt：被移除的代码 最后还是有必要看一下混淆后的代码结构，验证混淆是否成功。一个简单的办法，Android Studio的Build菜单下有一个Analyze APK选项，只需要先选择要分析的apk包，在之后的界面点击classes.dex即可看到混淆后的代码结构： 如果看到a b c d e 这样的包名，说明已经混淆成功了。 追溯Crash信息代码混淆后，也会导致Crash堆栈信息被混淆，难以阅读，增加定位问题位置的难度，一个混淆后的Crash堆栈信息类似这样，核心的信息都没了： 为了解决这个问题，可以使用\\tools\\proguard\\bin下的proguardgui.bat脚本将Crash堆栈信息还原到混淆前的状态。步骤如下： 双击打开脚本，选择左边的ReTrace选项 选择Mapping file文件，也就是混淆后打包后在app module/build/outputs/mapping/release下生成的mapping.txt 拷贝混淆后的堆栈信息 点击右下角的ReTrace!按钮，完成Crash堆栈信息的追溯 如下图中间部分就是追溯到的原Crash堆栈信息： 代码混淆基本的内容就这些了。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"Android性能优化","slug":"Android性能优化","date":"2017-11-12T14:06:01.000Z","updated":"2018-06-05T10:07:45.929Z","comments":true,"path":"2017/11/12/Android性能优化/","link":"","permalink":"http://yoursite.com/2017/11/12/Android性能优化/","excerpt":"","text":"Android性能优化，是Android开发中的重中之中，本文将讲述如何进行性能优化。 实际项目中的Android性能优化主要有如下几个方面： 编写高效代码—开发中总结出的一些小的性能Tips Layout布局优化 内存优化 编写高效代码编写高效代码的两个原则 不要写不需要的代码 不要分配不必要的内存 以上两个原则，似乎感觉是废话，但确实是编程的最高境界，也是我们编写代码的过程中时刻需要思考和注意的两个方面。 那么如何做到如上两点呢？下面列出了一些实际开发中的例子。 避免产生不必要的对象 例如： int的数组比Integer对象数组要好得多。两个平行的int数组要比一个（int,int）型的对象数组高效。这对于其他任何基本数据类型的组合都通用 两个平行数组Foo[],Bar[]会优于一个（Foo,Bar）对象的数组 通常来讲，尽量避免创建短时零时对象.少的对象创建意味着低频的垃圾回收 对象的分配和回收都是需要代价的；分配的内存越多，就会引起强制的内存回收；给用户体验增加小的停顿间隙，从而影响用户体验。 用户能感觉到卡顿的时间延迟是100ms ~ 200ms。 用静态代替虚拟 如果方法不需要访问某对像的字段，将该方法设置为静态，调用速度会提升15%~20% 对于常量使用static final static final int i = 1;static final String s = “a”; 注：这种优化仅仅是针对基本数据类型和String类型常量的，而非任意的引用类型。但尽可能的将常量声明为static final是一种好的做法。 避免内部的getter和setter 使用增强for循环 增强for循环要比普通循环快3倍 避免使用浮点数 通常，浮点数会比整型慢2/3 在没有JIT的设备上，调用方法所传递的对象采用具体的类型而非接口类型会更高效 void methodA(List list); void methodA(ArrayList list); 如上，后一种比前一种更高效。 数据库操作方法的优化尽量利用原生的SQL语句 原生的SQL省去了拼接sql语句的步骤，要比SqliteDatabase提供的insert、query、 update、delete等函数效率高。当数据库越大，差别也越大 当操作条数较多时，利用事务进行批处理 这样SQLite将把全部要执行的SQL语句先缓存在内存当中，然后等到COMMIT的时候一次性的写入数据库，这样数据库文件只被打开关闭了一次，效率自然大大的提高 12345db.beginTransaction(); for(Collection c:colls)&#123; insert(db, c);&#125; db.setTransactionSuccessful(); Http请求方式的选择Android 内置了两种HTTP方式:HttpURLConnection 和 Apache HttpClient。这两种都支持HTTPS、流式上传和下载、可配置超时、IPv6和连接池。在Gingerbread或者更高版本时，推荐使用HttpURLConnection。 这是因为： HttpURLConnection API 更简单，包更小。同时对传输数据的压缩和响应的缓存处理减少了网络带宽、提高了速度，也节省了电量。 优化布局Layouts是Android应用里直接影响用户体验的一个关键部分。如果Layout设计的不好，可能导致你的应用大量的内存占用从而导致UI响应很慢。Android SDK提供了工具帮助你分析你的Layouts的性能问题。 使用Hierarchy Viewer Hierarchy Viewer工具位于SDK \\tools\\目录下，该工具能分析出你的布局不合理和可以优化的地方。 大多数情况下，布局渲染时间差别较大的原因是在LinaerLayout里使用了layout_weight。这将会增加测量(Measure)的时间。你应该仔细的考虑是否有必要使用layout weight。 使用Lint 使用Lint — 查看你的view层级哪些地方可以优化 使用compound drawables - 一个包含了ImageView与TextView的LinearLayout可以被当作一个compound drawable来处理 使用 - 如果FramLayout仅仅是一个纯粹的（没有设置背景，间距等）布局根元素，我们可以使用merge标签来当作根标签 无用的分支 - 如果一个layout并没有任何子组件，那么可以被移除，这样可以提高效率 无用的父控件 - 如果一个layout只有子控件，没有兄弟控件，并且不是一个ScrollView或者根节点，而且没有设置背景，那么我们可以移除这个父控件，直接把子控件提升为父控件 深层次的layout - 尽量减少内嵌的层级，考虑使用更多平级的组件 RelativeLayout or GridLayout来提升布局性能，默认最大的深度是10 其他一些布局要点 使用include标签 使用ViewStub标签 优化App内存为了垃圾回收器能回收你系统的内存，你应该避免引起内存泄露，而且要在合适的时间点释放被引用的对象。 慎用Service Service执行完后台任务后要停止 使用IntentService IntentService不同于普通的Service之处是： 提交的task系统会post到子线程运行 当后台运行的task完成时，系统会stop掉IntentService Release memory when your user interface becomes hidden 例如，在该onStop（）里做释放资源（例如网络连接、注销广播等）的工作 使用优化后的集合容器 例如：SparseArray、SparseBooleanArray、LongSpareArray ….. 尽量避免使用枚举 相比于静态常量，枚举会有超过其两倍以上的内存开销，在android中需严格避免使用枚举 避免使用依赖注入框架 使用ProGuard消除没有使用的代码 使用zipalign优化和对齐你的apk 使用MAT分析和优化内存 I/O使用后需要关闭，数据库和Cursor等使用后要关闭 使用finalize()+MAT 分析内存泄露 end Android优化主要就是内存、布局和性能的优化，本文总结了Android中优化的一些知识点。如果还有其他我没有讲到的，欢迎给我留言。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"给RecyclerView加上折叠的效果","slug":"给RecyclerView加上折叠的效果","date":"2017-10-20T20:37:21.000Z","updated":"2018-06-05T10:07:45.973Z","comments":true,"path":"2017/10/21/给RecyclerView加上折叠的效果/","link":"","permalink":"http://yoursite.com/2017/10/21/给RecyclerView加上折叠的效果/","excerpt":"","text":"RecyclerView 有很高的自由度，可以说只有想不到没有做不到。这次用超简单的方法，让 RecyclerView 带上折叠的效果。 效果是这样的。 总结一下这个列表的特点，就是以下三点： 重叠效果； 层次感； 首项的差动。下面我们来一个个解决。 我们新建一个 ParallaxRecyclerView，让它继承 RecyclerView，并使用 LinearLayoutManager 作为布局管理器。 重叠效果 其实就是每一项都搭一部分在它前面那项而已。我们知道，RecyclerView 可以通过设置 ItemDecoration来实现列表的间隔效果，有没有想过要是把间隔设为负数会怎么样？比如： 1234567addItemDecoration(new ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom = -dp2px(context, 10); &#125; &#125;); 没错，这就实现了我们的重叠效果。 层次感 在 Material Design里是有Z轴这个概念的，我们可以给控件设置垂直于屏幕的高度，让不在同一高度的控件看起来有层次感。当然，我们要用 Material Design 的控件才有这个属性，这里我用的是 CardView。 我们给 ParallaxRecyclerView 增加一个滑动监听，在 onScrolled 方法里面做如下设置： 12345678910111213141516LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();int firstPosition = layoutManager.findFirstVisibleItemPosition();int lastPosition = layoutManager.findLastVisibleItemPosition();int visibleCount = lastPosition - firstPosition;//重置控件的高度int elevation = 1;for (int i = firstPosition - 1; i &lt;= (firstPosition + visibleCount) + 1; i++) &#123; View view = layoutManager.findViewByPosition(i); if (view != null) &#123; if (view instanceof CardView) &#123; ((CardView) view).setCardElevation(dp2px(context, elevation)); elevation += 5; &#125; &#125;&#125; 其中，setCardElevation 方法就是用来给 CardView 设置高度的，这里让每一项的高度比它的上一项高 5dp。 首项的差动 最后，我们想给第一项增加一个差动效果，这个同样在 onScrolled方法里面做处理就好了： 123View firstView = layoutManager.findViewByPosition(firstPosition);float firstViewTop = firstView.getTop();firstView.setTranslationY(-firstViewTop / 2.0f); 这样相当于第一项的滑动速度变成原来的一半。但这也会导致一个问题， 由于改变了控件的位置，当这个控件被复用时，会出现位置不正确的情况。所以我们在设置高度的时候，可以顺便把控件的位置复原了： 1234float translationY = view.getTranslationY();if (i &gt; firstPosition &amp;&amp; translationY != 0) &#123; view.setTranslationY(0);&#125; 这样就完成了一个带有简单折叠效果的 RecyclerView 了，妥妥的。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Service总结","slug":"Service总结","date":"2017-09-27T20:14:37.000Z","updated":"2018-06-05T10:07:45.953Z","comments":true,"path":"2017/09/28/Service总结/","link":"","permalink":"http://yoursite.com/2017/09/28/Service总结/","excerpt":"","text":"启动Service的方式 Context.startService(Intent)： 12Intent intent = new Intent(this, PlayService.class);startService(intent); Context.bindService(Intent,ServiceConnection,BIND_AUTO_CREATE) 12345678910111213private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e(\"result\",\"绑定成功\"); PlayService.MyBinder binder = (PlayService.MyBinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e(\"result\",\"解绑成功\"); &#125;&#125;;Intent intent = new Intent(this,PlayService.class);bindService(intent,conn,BIND_AUTO_CREATE); 两种启动方式区别： startService启动之后，如果没有调用stopSelf()或者stopService()就会一直在后台运行。bindService启动Service之后，在启动它的组件被销毁后也会解绑并销毁。 startService()启动Service到结束，Service经历生命周期的是onCreate()、onStartCommand()、onDestory()。而bindService()启动Service，Service经历的生命周期是onCreate()、onBind()、onUnbind()、onDestory() 如果即startService又bindService启动了Service，要分别unBindService()、stopSelf()/stopService()关闭Service。这里关闭没有顺序限制的，比如：先startService，后bindService。结束时先进行unBindService，stopService，还是顺序反过来都是没有问题的。 启动之后再次启动的生命周期 在startService之后，再进行startService，只会再次执行Service的onStartCommond方法，而不会再执行onCreate 在bindService之后，再进行bindService，不会再执行Service的onBind。 和Activity交互 Activity在启动Service的时候，可以通过Intent.putExtra来给Service传递数据(两种方式均可) 通过bindService()启动Service，通过onBind()返回的Binder来指挥Service来进行操作 123class MyBinder extends Binder&#123; public void action()&#125; Service给Activity回传数据，可以通过在Service中发送广播，在Activity注册广播接收数据 Service是运行在UI线程的 如果需要在Service中做耗时操作，需要另外起一个线程。 当然你还可以使用IntentService IntentServiceIntentService优点如下 Service中的事情处理完成之后，它会调用stopSelf()结束自己 Service可以直接处理耗时操作 IntentService的基本使用如下：1234567891011121314151617181920212223public class DownloadService extends IntentService &#123; public DownloadService() &#123; super(\"DownLoadService\"); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.e(\"result\", \"onCreate\"); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; super.onStart(intent, startId); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; Log.e(\"result\", \"onStartCommand\"); return super.onStartCommand(intent, flags, startId); &#125; @Override protected void onHandleIntent(Intent intent) &#123; Log.e(\"result\", \"onHandleIntent\"); &#125;&#125; 需要注意的是：它的构造方法必须给他提供一个无参构造方法，名字就命名为类名即可。 IntentService的原理 IntentService封装了HandlerThread和Handler，HandlerThread就是一个Thread（具体再分析），Handler handler = new Handler(handerThread.getLooper())，handler是由子线程中的Looper构造的，相当于在子线程中有个一个MessageQueue消息队列，我们每次startService()，就是sendMessage()添加一个消息到队列中，然后该childThread的Looper不断的从MessageQueue中取出消息去处理。 记住：Handler构造中的Looper在哪个线程，该Handler就为哪个线程服务。如果是无参构造就是MainThread，因为内部调用了looper.myLooper()。 补充onStartCommand()方法的返回值问题： START_STICKY：如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。 START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。 START_REDELIVER_INTENT：重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。 START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Android通用流行框架大全","slug":"Android通用流行框架大全","date":"2017-09-09T21:56:39.000Z","updated":"2018-06-05T10:07:45.952Z","comments":true,"path":"2017/09/10/Android通用流行框架大全/","link":"","permalink":"http://yoursite.com/2017/09/10/Android通用流行框架大全/","excerpt":"","text":"1. 缓存 名称 描述 DiskLruCache Java实现基于LRU的磁盘缓存 Robospice 2.图片加载 名称 描述 Android Universal Image Loader 一个强大的加载，缓存，展示图片的库 Picasso 一个强大的图片下载与缓存的库 Fresco 一个用于管理图像和他们使用的内存的库 Glide 一个图片加载和缓存的库 3. 图片处理 名称 描述 Picasso-transformations 一个为Picasso提供多种图片变换的库 Glide-transformations 一个为Glide提供多种图片变换的库 Android-gpuimage 基于OpenGL的Android过滤器 4. 网络请求 名称 描述 Android Async HTTP Android异步HTTP库 AndroidAsync 异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。 OkHttp 一个Http与Http/2的客户端 Retrofit 类型安全的Http客户端 Volley Google推出的Android异步网络请求框架和图片加载框架 5. 网络解析 名称 描述 Gson 一个Java序列化/反序列化库，可以将JSON和java对象互相转换 Jackson Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象 Fastjson Java上一个快速的JSON解析器/生成器 HtmlPaser 一种用来解析单个独立html或嵌套html的方式 Jsoup 一个以最好的DOM，CSS和jQuery解析html的库 6. 数据库 名称 描述 OrmLite JDBC和Android的轻量级ORM java包 Sugar 用超级简单的方法处理Android数据库 GreenDAO 一种轻快地将对象映射到SQLite数据库的ORM解决方案 ActiveAndroid 以活动记录方式为Android SQLite提供持久化 SQLBrite SQLiteOpenHelper 和ContentResolver的轻量级包装 Realm 移动数据库：一个SQLite和ORM的替换品 7. 依赖注入 名称 描述 ButterKnife 将Android视图和回调方法绑定到字段和方法上 Dagger2 一个Android和java快速依赖注射器。 AndroidAnotations 快速安卓开发。易于维护 RoboGuice Android平台的Google Guice 8. 图表 名称 描述 WilliamChart 创建图表的Android库 HelloCharts 兼容到API8的Android图表库 MPAndroidChart 一个强大的Android图表视图/图形库 9. 后台处理 名称 描述 Tape 一个轻快的，事务性的，基于文件的FIFO的库 Android Priority Job Queue 一个专门为Android轻松调度任务的工作队列 10. 事件总线 名称 描述 EventBus 安卓优化的事件总线，简化了活动、片段、线程、服务等的通信 Otto 一个基于Guava的增强的事件总线 11. 响应式编程 名称 描述 RxJava JVM上的响应式扩展 RxJavaJoins 为RxJava提供Joins操作 RxAndroid Android上的响应式扩展，在RxJava基础上添加了Android线程调度 RxBinding 提供用RxJava绑定Android UI的API Agera Android上的响应式编程 12. Log框架 名称 描述 Logger 简单，漂亮，强大的Android日志工具 Hugo 在调试版本上注解的触发方法进行日志记录 Timber 一个小的，可扩展的日志工具 Xutils 13. 测试框架 名称 描述 Mockito Java编写的Mocking单元测试框架 Robotium Android UI 测试 Robolectric Android单元测试框架 Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等 14. 调试框架 名称 描述 Stetho 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试 15. 性能优化 名称 描述 LeakCanary 内存泄漏检测工具 ACRA Android应用程序崩溃报告 16. 数据统计 名称 描述 友盟统计 百度统计 17. 崩溃收集 名称 描述 腾讯bugly bugtags 18. 即时通讯 名称 描述 环信 融云 阿里百川 19. 推送 名称 描述 小米推送 极光推送 个推 20. 内嵌浏览器 名称 描述 腾讯X5内核 百度T5内核","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"http和https","slug":"http和https","date":"2017-08-20T20:33:46.000Z","updated":"2018-06-05T10:07:45.962Z","comments":true,"path":"2017/08/21/http和https/","link":"","permalink":"http://yoursite.com/2017/08/21/http和https/","excerpt":"","text":"HTTP基础 超文本传输协议（HTTP，HyperText Transfer Protocol），默认端口：80 特点 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 请求报文 一般由请求行、请求头、空行、请求体四部分组成。 响应报文 一般由状态行、消息报头、空行、响应正文四部分组成。 常见状态码 200 OK：客户端请求成功 302 Move temporarily：请求的资源临时从不同的 URI响应请求，重定向 304 Not Modified：有效缓存 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现 500 Internal Server Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 常见通用报头 Cache-Control：指定请求和响应遵循的缓存机制 常用请求报头 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接 Referer：允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等 Range：可以请求实体的一个或者多个子范围 常见响应报头 Location：用于重定向接受者到一个新的位置，常用在更换域名的时候Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的 常见实体报头 Content-Type：发送给接收者的实体正文的媒体类型 Content-Lenght：实体正文的长度 Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制 Last-Modified：实体报头用于指示资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间 SPDY 2012年google提出的SPDY方案，主要解决： 降低延迟：SPDY采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式； 请求优先级：SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应； header压缩：选择合适的压缩算法可以减小包的大小和数量； 基于HTTPS的加密协议传输 服务端推送 Http2.0 可以看成是SPDY的升级版。 Http2.0与SPDY的区别 HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE Http2.0新特性 新的二进制格式：HTTP1.x的解析是基于文本的 多路复用：即连接共享，即每一个request都是是用作连接共享机制的 header压缩 服务端推送 HTTPS (Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，即HTTP下加入SSL层，端口：443 HTTPS握手流程 客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息； 服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书； 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步； 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器； 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器； 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）； 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化； 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束； 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束； SSL 的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 Android中处理Https处理 javax.net.ssl.SSLHandshakeException: 证书验证失败 123456789101112131415161718192021222324252627282930313233343536/** * HTTPS未知的证书颁发机构处理方法 * Android客户端存储证书 * * @param input 待信任的CA证书流 * @return SSLContext */public static SSLContext getSSLContext(InputStream input) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); Certificate ca = cf.generateCertificate(input); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setCertificateEntry(\"ca\", ca); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(keyStore); sslContext.init(null, tmf.getTrustManagers(), null); input.close(); return sslContext; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null;&#125; 单独使用SSL和HTTP 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 单独使用SSL + HTTP时 * @param trustManagers * @return */public static SSLContext getSSLContext(TrustManager[] trustManagers) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagers, null); return sslContext; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static TrustManager[] sDefaultTrustManagers = new TrustManager[] &#123;new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; // TODO: 2018/1/23双向校验中，向服务端发客户端证书 &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; // TODO: 2018/1/23 双向校验中，校验服务端证书 &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125;&#125;&#125;;public static HostnameVerifier sHostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; // 不验证主机名 return true; &#125;&#125;;","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"Android消息机制(Handler)","slug":"Android消息机制-Handler","date":"2017-07-12T20:20:05.000Z","updated":"2018-06-05T10:07:45.930Z","comments":true,"path":"2017/07/13/Android消息机制-Handler/","link":"","permalink":"http://yoursite.com/2017/07/13/Android消息机制-Handler/","excerpt":"","text":"答疑解惑 系统为什么不允许在子线程中访问UI？ Android的UI控件不是线程安全的 增加上锁机制会导致: UI访问逻辑复杂、降低UI访问效率 区分线程的数据存储 ThreadLocal 工作原理MessageQueue 内部由单链表实现，主要包含两个操作：插入(enqueueMessage)和读取(next)。 Looper 从MessageQueue中不停查看是否有新消息，如果有新消息立即处理。 系统已经为主线程创建了Looper，可以使用getMainLooper获取 其他线程使用Looper.prepare()获取，使用Looper.loop()启动 loop方法是一个死循环，运行在创建Looper的线程 Handler 负责发送和接收消息。可以通过post和send方法发送消息，post方法最终也会走入send的逻辑。 Handler工作过程: Handler消息处理流程:","categories":[],"tags":[{"name":"通信","slug":"通信","permalink":"http://yoursite.com/tags/通信/"}]},{"title":"匿名类用到的变量为什么一定要是final的呢?","slug":"匿名类用到的变量为什么一定要是final的呢","date":"2017-06-11T19:47:16.000Z","updated":"2018-06-05T10:07:45.971Z","comments":true,"path":"2017/06/12/匿名类用到的变量为什么一定要是final的呢/","link":"","permalink":"http://yoursite.com/2017/06/12/匿名类用到的变量为什么一定要是final的呢/","excerpt":"","text":"提起final变量，大家通常知道这些： final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 final类不能被继承，没有子类，final类中的方法默认是final的。 final方法不能被子类的方法覆盖，但可以被继承。 final不能用于修饰构造方法 final 常与 static一起用，作为常量来使用。 提问：在一些方法的参数中定义为final是干嘛的? 答: 不希望这个变量在方法里面被修改，防止无意的修改而影响到调用方法外的变量。 不知道这个答案是从哪个语言带过来的， 感觉把final当成const了。 假设出现以下方法定义:12void fuc(final String string);void fuc1(String string); 对于这种写法，String本身就是一个不可以变的对象，并且其是作为基本参数类型，传参进入后，方法里面改变了String的值外面也不会改变，因此这两种写法实际结果是一样.只不过加了final，在string被赋值时IDE会直接报红。12void fuc(final A a);void fuc(A a); 对于这种写法， A是一个对象，这样写不是代表A里面内容不能被改变，而是a不能被赋值为新对象了. 为什么使用匿名内部类的时候参数一定要加上final让我们写一个类看一下1234567891011121314151617public class Test &#123; class Person &#123; String name; int age; &#125; private void func(final Person a) &#123; new Thread() &#123; @Override public void run() &#123; super.run(); a.name = \"hello\"; &#125; &#125;.start(); &#125;&#125; javac一下该文件，生成了3个class文件，我们看其中的两个 内部类Person的class12345678class Test$Person &#123; String name; int age; Test$Person(Test var1) &#123; this.this$0 = var1; &#125;&#125; 匿名内部类Thread的class1234567891011class Test$1 extends Thread &#123; Test$1(Test var1， Person var2) &#123; this.this$0 = var1; this.val$a = var2; &#125; public void run() &#123; super.run(); this.val$a.name = \"hello\"; &#125;&#125; 从这个匿名内部类的class文件我们可以看出两点 其构造参数中增加了一个调用类.即我们所说的持有外部类的引用. 我们定义的final参数被当做构造方法传了进来.至于为什么要把这个参数当做构造函数参数传进来，因为调用它的方法参数是存在栈里面的，其生命周期随着这个方法的调用结束而结束.而我们的异步任务可不是，有可能会执行很长时间。 那么final的关键字作用就凸显了，Person参数要拷贝到内部类中，而拷贝会带来不一致性， func中是一个异步的操作，负责改变a的name的值. 假设Person a 不是final的.那么a可以被任意指向新的对象，那么传给这个异步任务的对象还是老对象，这就造成了不一致.因此Java需要强制约束对象的一致性.因此必须是final的。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"通过H5唤起本地app","slug":"通过H5唤起本地app","date":"2017-05-08T21:33:43.000Z","updated":"2018-06-05T10:07:45.986Z","comments":true,"path":"2017/05/09/通过H5唤起本地app/","link":"","permalink":"http://yoursite.com/2017/05/09/通过H5唤起本地app/","excerpt":"","text":"H5如何打开或者说唤起手机本地的app，有以下两种： 第一种方式： 通过在html的a标签里面的href中直接配置android端的schema，当然，如果有host其他的配置，跟在后面就可以了，android端配置和代码如下： android端配置：12345678910111213&lt;activity android:name = \".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name = \"android.intent.action.MAIN\"/&gt; &lt;category android:name = \"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;data android:host=\"baidu.com\" android:scheme=\"testapp\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 注：如果这个是配置在启动页要和标签并列在一起，不然运行后手机app的图标会没有；注意schema协议要小写,否则会有不能响应的异常! html代码： 123456789&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"testapp://baidu.com/?pid=1\"&gt;打开app&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 这里我们来看看schema拼接协议的格式： &lt; a href=”[scheme]://[host]/[path]?[query]”&gt;启动应用程序&lt; /a&gt; 各个项目含义如下所示： scheme：判别启动的App。 host：适当记述 path：传值时必须的key ※没有也可以 query：获取值的Key和Value ※没有也可以 以上就能实现打开本地的app了，当然是在app存在的情况下，否则的话没有反应。 我们有些时候在唤起本地app的时候可能会向app传递一些参数，这些参数我们就可以配置在path或者query里，我们只需要在oncreate里面获取就可以了。 代码如下： 12345Intent intent = getIntent(); Uri uri = intent.getData(); if (uri != null) &#123; String pid = uri.getQueryParameter(\"pid\");&#125; 如果还想要获取android里面配置的schema协议的话，还可以这样: 12345678910111213141516171819202122232425Uri uri = getIntent().getData();if(uri != null) &#123; // 完整的url信息 String url = uri.toString(); Log.e(TAG, \"url: \" + uri); // scheme部分 String scheme = uri.getScheme(); Log.e(TAG, \"scheme: \" + scheme); // host部分 String host = uri.getHost(); Log.e(TAG, \"host: \" + host); //port部分 int port = uri.getPort(); Log.e(TAG, \"host: \" + port); // 访问路径 String path = uri.getPath(); Log.e(TAG, \"path: \" + path); List&lt;String&gt; pathSegments = uri.getPathSegments(); // Query部分 String query = uri.getQuery(); Log.e(TAG, \"query: \" + query); //获取指定参数值 String pid = uri.getQueryParameter(\"pid\"); Log.e(TAG, \"pid: \" + pid);&#125; 如何判断一个Schema是否有效 : 1234567PackageManager packageManager = getPackageManager();Intent intent = newIntent(Intent.ACTION_VIEW, Uri.parse(\"testapp://baidu.com:80/article?goodsId=10011002\"));List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(intent, 0);booleanisValid = !activities.isEmpty();if(isValid) &#123; startActivity(intent);&#125; 这种方式也是我百度到的最多的方式，但是这样就带来了一个问题了，上面的需求说的是“在页面上有一个连接， 如果用户安装了APP，则点击打开对应的APP；如果用户没有安装，则点击打开对应的设置连接”，这明显就不符合需求了，这只能作为一些个别需求来使用了。 第二种方式： 既然通过在href配置schema协议不行，那就只能通过js代码来实现了，只有这样才能根据判断实现app有的时候就打开，没有的时候就跳转到下载链接下载。 我们知道，js是无法判断手机是否安装了某款app的，所以我们只能够曲线救国了，我们可以获取时间如果，长时间不能呼起app则默认为没有安装这款app，然后跳转到下载页。当然这不是我想出来的，是网上的各位大佬的想法。在这里又要细分为两种情况了。 1.直接唤醒 说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式兼容性较好，如果安装了app，在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器、QQ浏览器、百度浏览器 )和QQ客户端中，能唤醒。微信、新浪微博客户端、腾讯微博客户端无法唤醒。 代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;点击唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式。兼容性较好，如果安装了app，在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )和QQ客户端中，能唤醒。微信 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;a href=\"zjmobile://platformapi/startapp\" id=\"zjmobliestart\" target=\"_blank\"&gt;唤醒浙江移动手机营业厅！&lt;/a&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; return function()&#123; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;; &#125;applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.点击唤醒 说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面。兼容性一般：在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器 QQ浏览器、百度浏览器 )能唤醒。微信、QQ客户端、新浪微博客户端、 腾讯微博客户端无法唤醒。 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;直接唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面兼容性一般：在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )能唤醒。微信 QQ客户端 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;p id=\"zjmobliestart\"&gt;唤醒浙江移动手机营业厅！&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; window.location = 'zjmobile://platformapi/startapp'; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;document.getElementById(\"zjmobliestart\").onclick = applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样就完成了我们的需求了。 还要注意的是，如果是在微信中唤起本地app，手机的微信中，是利用微信内置的浏览器打开那个简单的HTML页面，注意：直接打开scheme://host/datastring是不可行的，微信不会把这串字符解析成网址，必须包装成网页才能借助微信的浏览器打开。进入后就是我们刚刚设计的页面。这个时候，直接点击“启动应用程序”是不会唤醒之前安装的APP的，因为微信做了屏蔽，你需要在右上角的菜单中选择“在浏览器中打开”。这个时候就可以唤醒你想唤醒的app了。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"Android中的各种Span","slug":"Android中的各种Span","date":"2017-04-16T20:38:02.000Z","updated":"2018-06-05T10:07:45.920Z","comments":true,"path":"2017/04/17/Android中的各种Span/","link":"","permalink":"http://yoursite.com/2017/04/17/Android中的各种Span/","excerpt":"","text":"简介在android.text.style包下,有一些Span类,可以提供我们完成一些在TextView中的特殊内容。(比如:部分内容颜色、字体、大小不同等等)。本篇博客主要讲解一些span的用法，以及结合Android动画机制制作出十分酷炫的动画Span。 给字符添加边框FrameSpan实现给相应的字符序列添加边框的效果，整体思路其实比较简单。 计算字符序列的宽度； 根据计算的宽度、上下坐标、起始坐标绘制矩形； 绘制文字 展现效果如下所示： 再来看一下代码，其实代码十分简单。12345678910111213141516171819202122public class FrameSpan extends ReplacementSpan &#123; private final Paint mPaint; private int mWidth; public FrameSpan() &#123; mPaint = new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLUE); mPaint.setAntiAlias(true); &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123; //return text with relative to the Paint mWidth = (int) paint.measureText(text, start, end); return mWidth; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; //draw the frame with custom Paint canvas.drawRect(x, top, x + mWidth, bottom, mPaint); canvas.drawText(text, start, end, x, y, paint); &#125;&#125; 用法示例：1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); final SpannableString spannableString = new SpannableString( \"helloworld,helloworld!helloworld,helloworld!helloworld,\" + \"helloworld!helloworld,helloworld!\"); spannableString.setSpan(new FrameSpan(), 0, 30, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 图文垂直居中系统提供的ImageSpan和DynamicDrawableSpan只能实现图片和文字底部对齐或者是baseline对齐，现在VerticalImageSpan可以实现图片和文字居中对齐。 图中的图片保持了和文字居中对齐，现在来看看VerticalImageSpan的源码。123456789101112131415161718192021222324252627282930313233343536public class VerticalImageSpan extends ImageSpan &#123; private Drawable drawable; public VerticalImageSpan(Drawable drawable) &#123; super(drawable); this.drawable=drawable; &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fontMetricsInt) &#123; Drawable drawable = getDrawable(); if(drawable==null)&#123; drawable= this.drawable; &#125; Rect rect = drawable.getBounds(); if (fontMetricsInt != null) &#123; Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top; int drHeight = rect.bottom - rect.top; int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fontMetricsInt.ascent = -bottom; fontMetricsInt.top = -bottom; fontMetricsInt.bottom = top; fontMetricsInt.descent = top; &#125; return rect.right; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Drawable drawable = getDrawable(); canvas.save(); int transY = ((bottom - top) - drawable.getBounds().bottom) / 2 + top; canvas.translate(x, transY); drawable.draw(canvas); canvas.restore(); &#125;&#125; 在geSize方法中通过fontMetricsInt设置从而实现图片和文字居中对齐，其实计算的根本为计算baseline的位置，因为TextView是按照baseline对齐的。 分析getSize方法可以知道这个图片的baseline为图片中央往下fontHeight / 2，这样也就实现了图片和文字的居中对齐。 用法示例：12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); Drawable drawable = getResources().getDrawable(R.drawable.ic_launcher); drawable.setBounds(0, 0, 50, 50); final SpannableString spannableString = new SpannableString( \"helloworld,helloworld!helloworld,helloworld!helloworld,\" + \"helloworld!helloworld,helloworld!\"); spannableString.setSpan(new VerticalImageSpan(drawable), 0, 1, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 字体多色渐变彩虹样的Span，其实实现起来也是很简单的，主要是用到了Paint的Shader技术，效果如下所示： 源代码如下所示：123456789101112131415private static class RainbowSpan extends CharacterStyle implements UpdateAppearance &#123; private final int[] colors; public RainbowSpan(Context context) &#123; colors = context.getResources().getIntArray(R.array.rainbow); &#125; @Override public void updateDrawState(TextPaint paint) &#123; paint.setStyle(Paint.Style.FILL); Shader shader = new LinearGradient(0, 0, 0, paint.getTextSize() * colors.length, colors, null, Shader.TileMode.MIRROR); Matrix matrix = new Matrix(); matrix.setRotate(90); shader.setLocalMatrix(matrix); paint.setShader(shader); &#125;&#125; 由于paint使用shader是从上到下进行绘制，因此这里需要用到矩阵，然后将矩阵旋转90度。 用法示例：1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); final SpannableString spannableString = new SpannableString( &quot;helloworld,helloworld!helloworld,helloworld!helloworld,&quot; + &quot;helloworld!helloworld,helloworld!&quot;); spannableString.setSpan(new RainbowSpan(this), 0, 40, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 字体多色渐变动画效果 如果要实现一个动画的彩虹样式，那么该如何实现呢？ 其实结合上面的RainbowSpan和AnimateForegroundColorSpan的例子便可以实现AnimatedRainbowSpan。 实现思路：通过ObjectAnimator动画调整RainbowSpan中矩阵的平移，从而实现动画彩虹的效果。 代码如下所示： 首先是AnimatedColorSpan1234567891011121314151617181920212223242526272829private static class AnimatedColorSpan extends CharacterStyle implements UpdateAppearance &#123; private final int[] colors; private Shader shader = null; private Matrix matrix = new Matrix(); private float translateXPercentage = 0; public AnimatedColorSpan(Context context) &#123; colors = context.getResources().getIntArray(R.array.rainbow); &#125; public void setTranslateXPercentage(float percentage) &#123; translateXPercentage = percentage; &#125; public float getTranslateXPercentage() &#123; return translateXPercentage; &#125; @Override public void updateDrawState(TextPaint paint) &#123; paint.setStyle(Paint.Style.FILL); float width = paint.getTextSize() * colors.length; if (shader == null) &#123; shader = new LinearGradient(0, 0, 0, width, colors, null, Shader.TileMode.MIRROR); &#125; matrix.reset(); matrix.setRotate(90); matrix.postTranslate(width * translateXPercentage, 0); shader.setLocalMatrix(matrix); paint.setShader(shader); &#125; &#125;&#125; 配合属性动画：1234567891011121314151617181920212223242526272829303132333435363738public class AnimatedRainbowSpanActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animated_rainbow_span); final TextView textView = (TextView) findViewById(R.id.text); String text = textView.getText().toString(); AnimatedColorSpan span = new AnimatedColorSpan(this); final SpannableString spannableString = new SpannableString(text); String substring = getString(R.string.animated_rainbow_span).toLowerCase(); int start = text.toLowerCase().indexOf(substring); int end = start + substring.length(); spannableString.setSpan(span, start, end, 0); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat( span, ANIMATED_COLOR_SPAN_FLOAT_PROPERTY, 0, 100); objectAnimator.setEvaluator(new FloatEvaluator()); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; textView.setText(spannableString); &#125; &#125;); objectAnimator.setInterpolator(new LinearInterpolator()); objectAnimator.setDuration(DateUtils.MINUTE_IN_MILLIS * 3); objectAnimator.setRepeatCount(ValueAnimator.INFINITE); objectAnimator.start(); &#125;private static final Property&lt;AnimatedColorSpan, Float&gt; ANIMATED_COLOR_SPAN_FLOAT_PROPERTY = new Property&lt;AnimatedColorSpan, Float&gt;(Float.class, \"ANIMATED_COLOR_SPAN_FLOAT_PROPERTY\") &#123; @Override public void set(AnimatedColorSpan span, Float value) &#123; span.setTranslateXPercentage(value); &#125; @Override public Float get(AnimatedColorSpan span) &#123; return span.getTranslateXPercentage(); &#125;&#125;; 打字效果 有了上面的例子，写TypeWriterSpan就变得十分简单了。 先创建TypeWriterSpanGroup1234567891011121314151617181920212223242526272829public class TypeWriterSpanGroup &#123; private final float mAlpha; private final ArrayList&lt;MutableForegroundColorSpan&gt; mSpans; public TypeWriterSpanGroup(float alpha) &#123; mAlpha = alpha; mSpans = new ArrayList&lt;MutableForegroundColorSpan&gt;(); &#125; public void addSpan(MutableForegroundColorSpan span) &#123; span.setAlpha((int) (mAlpha * 255)); mSpans.add(span); &#125; public void setAlpha(float alpha) &#123; int size = mSpans.size(); float total = 1.0f * size * alpha; for(int index = 0 ; index &lt; size; index++) &#123; MutableForegroundColorSpan span = mSpans.get(index); if(total &gt;= 1.0f) &#123; span.setAlpha(255); total -= 1.0f; &#125; else &#123; span.setAlpha((int) (total * 255)); total = 0.0f; &#125; &#125; &#125; public float getAlpha() &#123; return mAlpha; &#125;&#125; 然后添加Span与添加动画，整体使用示例如下：1234567891011121314151617181920212223242526@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextView tv = findViewById(R.id.id_tv_framespan); String val = \"helloworld,helloworld!helloworld,helloworld!helloworld\"; final SpannableString spannableString = new SpannableString(val); // 添加Span final TypeWriterSpanGroup group = new TypeWriterSpanGroup(0); for(int index = 0 ; index &lt;= val.length()-1 ; index++) &#123; MutableForegroundColorSpan span = new MutableForegroundColorSpan(); group.addSpan(span); spannableString.setSpan(span, index, index + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; // 添加动画 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(group, TYPE_WRITER_GROUP_ALPHA_PROPERTY, 0.0f, 1.0f); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //refresh tv.setText(spannableString); &#125; &#125;); objectAnimator.setDuration(5000); objectAnimator.start();&#125; 动画属性变化器代码如下：1234567891011private static final Property&lt;TypeWriterSpanGroup, Float&gt; TYPE_WRITER_GROUP_ALPHA_PROPERTY = new Property&lt;TypeWriterSpanGroup, Float&gt;(Float.class, \"TYPE_WRITER_GROUP_ALPHA_PROPERTY\") &#123; @Override public void set(TypeWriterSpanGroup spanGroup, Float value) &#123; spanGroup.setAlpha(value); &#125; @Override public Float get(TypeWriterSpanGroup spanGroup) &#123; return spanGroup.getAlpha(); &#125; &#125;; 涉及到的类：12345678910111213141516171819public class MutableForegroundColorSpan extends CharacterStyle implements UpdateAppearance &#123; public static final String TAG = \"MutableForegroundColorSpan\"; private int mColor = Color.BLACK; private int mAlpha = 0 ; @Override public void updateDrawState(TextPaint tp) &#123; tp.setColor(mColor); tp.setAlpha(mAlpha); &#125; public int getColor() &#123; return mColor; &#125; public void setColor(int color) &#123; this.mColor = color; &#125; public void setAlpha(int alpha) &#123; mAlpha = alpha; &#125;&#125;","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"实现上滑屏幕，隐藏底部菜单栏","slug":"实现上滑屏幕，隐藏底部菜单栏","date":"2017-03-25T22:02:50.000Z","updated":"2018-06-05T10:07:45.972Z","comments":true,"path":"2017/03/26/实现上滑屏幕，隐藏底部菜单栏/","link":"","permalink":"http://yoursite.com/2017/03/26/实现上滑屏幕，隐藏底部菜单栏/","excerpt":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。","text":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。本文主要实现的功能是底部菜单栏随用户手势滑动而变化。 正常状态 上滑之后 布局代码这个功能实现起来比较简单，主要利用了CoordinatorLayout的layout_behavior的属性。具体代码如下： 123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/toolbar\"/&gt; &lt;include layout=\"@layout/container\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/bottom_navigation\" style=\"@style/Widget.Design.BottomNavigationView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_gravity=\"bottom\" android:background=\"@color/viewBackground\" app:elevation=\"16dp\" app:itemIconTint=\"@drawable/nav_item_color_state\" app:itemTextColor=\"@drawable/nav_item_color_state\" app:layout_behavior=\"com.testapp.widget.behavior.BottomNavigationBehavior\" app:menu=\"@menu/bottom_navigation_main\"/&gt; 上面是activity_main的布局代码，第一个是菜单栏，第二个是内容界面，第三个是bottom。bottom导航栏这里采用是BottomNavigationView，具体用法不再介绍。这里主要看一下BottomNavigationView的app:layout_behavior属性，该属性是协调布局特有的。网上的一版用法是 1app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" 虽然表面上看是一个字符串，其实在里面调用的也是一个view类。这次我们通过自定义这个behavior类，实现底部菜单栏的显隐性。 java实现类1234567891011121314151617181920212223242526272829303132333435public class BottomNavigationBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private ObjectAnimator outAnimator, inAnimator; public BottomNavigationBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; // 垂直滑动 @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0) &#123;// 上滑隐藏 if (outAnimator == null) &#123; outAnimator = ObjectAnimator.ofFloat(child, \"translationY\", 0, child.getHeight()); outAnimator.setDuration(200); &#125; if (!outAnimator.isRunning() &amp;&amp; child.getTranslationY() &lt;= 0) &#123; outAnimator.start(); &#125; &#125; else if (dy &lt; 0) &#123;// 下滑显示 if (inAnimator == null) &#123; inAnimator = ObjectAnimator.ofFloat(child, \"translationY\", child.getHeight(), 0); inAnimator.setDuration(200); &#125; if (!inAnimator.isRunning() &amp;&amp; child.getTranslationY() &gt;= child.getHeight()) &#123; inAnimator.start(); &#125; &#125; &#125;&#125; 这个类的就是刚刚那个app:layout_behavior=”com.meiji.toutiao.widget.behavior.BottomNavigationBehavior”属性标明的类，看起来很简单，继承了Behavior抽象类，然后实现了两个方法。 onStartNestedScroll：这个方法主要用于监听协调布局的子view的滚动事件，当此方法返回true，表示要消耗此动作，继而执行下面的onNestedPreScroll方法，我们在代码中返回的是，滚动轴是不是竖直滚动轴。如果是的话，就返回trueonNestedPreScroll：这个方法就比较简单了，当用户上滑的时候，隐藏底部菜单栏，这里使用了动画退出，使用了ObjectAnimator.ofFloat方法，第一个是view对象，指的就是bottom，第二个是Y轴的变化，第三个是Y轴变化的多少，接下来设置动画秒数。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]}]}