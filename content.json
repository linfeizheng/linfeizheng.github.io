{"meta":{"title":"郑林飞","subtitle":null,"description":null,"author":"郑林飞","url":"http://yoursite.com"},"pages":[{"title":"郑林飞个人简介","date":"2018-01-28T20:06:19.000Z","updated":"2018-01-28T12:07:19.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介郑林飞个人简介"}],"posts":[{"title":"Android中的各种Span","slug":"Android中的各种Span","date":"2018-02-22T20:38:02.000Z","updated":"2018-02-22T13:02:54.000Z","comments":true,"path":"2018/02/23/Android中的各种Span/","link":"","permalink":"http://yoursite.com/2018/02/23/Android中的各种Span/","excerpt":"","text":"简介在android.text.style包下,有一些Span类,可以提供我们完成一些在TextView中的特殊内容。(比如:部分内容颜色、字体、大小不同等等)。本篇博客主要讲解一些span的用法，以及结合Android动画机制制作出十分酷炫的动画Span。 给字符添加边框FrameSpan实现给相应的字符序列添加边框的效果，整体思路其实比较简单。 计算字符序列的宽度； 根据计算的宽度、上下坐标、起始坐标绘制矩形； 绘制文字 展现效果如下所示： 再来看一下代码，其实代码十分简单。12345678910111213141516171819202122public class FrameSpan extends ReplacementSpan &#123; private final Paint mPaint; private int mWidth; public FrameSpan() &#123; mPaint = new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLUE); mPaint.setAntiAlias(true); &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123; //return text with relative to the Paint mWidth = (int) paint.measureText(text, start, end); return mWidth; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; //draw the frame with custom Paint canvas.drawRect(x, top, x + mWidth, bottom, mPaint); canvas.drawText(text, start, end, x, y, paint); &#125;&#125; 用法示例：1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); final SpannableString spannableString = new SpannableString( \"helloworld,helloworld!helloworld,helloworld!helloworld,\" + \"helloworld!helloworld,helloworld!\"); spannableString.setSpan(new FrameSpan(), 0, 30, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 图文垂直居中系统提供的ImageSpan和DynamicDrawableSpan只能实现图片和文字底部对齐或者是baseline对齐，现在VerticalImageSpan可以实现图片和文字居中对齐。 图中的图片保持了和文字居中对齐，现在来看看VerticalImageSpan的源码。123456789101112131415161718192021222324252627282930313233343536public class VerticalImageSpan extends ImageSpan &#123; private Drawable drawable; public VerticalImageSpan(Drawable drawable) &#123; super(drawable); this.drawable=drawable; &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fontMetricsInt) &#123; Drawable drawable = getDrawable(); if(drawable==null)&#123; drawable= this.drawable; &#125; Rect rect = drawable.getBounds(); if (fontMetricsInt != null) &#123; Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top; int drHeight = rect.bottom - rect.top; int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fontMetricsInt.ascent = -bottom; fontMetricsInt.top = -bottom; fontMetricsInt.bottom = top; fontMetricsInt.descent = top; &#125; return rect.right; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Drawable drawable = getDrawable(); canvas.save(); int transY = ((bottom - top) - drawable.getBounds().bottom) / 2 + top; canvas.translate(x, transY); drawable.draw(canvas); canvas.restore(); &#125;&#125; 在geSize方法中通过fontMetricsInt设置从而实现图片和文字居中对齐，其实计算的根本为计算baseline的位置，因为TextView是按照baseline对齐的。 分析getSize方法可以知道这个图片的baseline为图片中央往下fontHeight / 2，这样也就实现了图片和文字的居中对齐。 用法示例：12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); Drawable drawable = getResources().getDrawable(R.drawable.ic_launcher); drawable.setBounds(0, 0, 50, 50); final SpannableString spannableString = new SpannableString( \"helloworld,helloworld!helloworld,helloworld!helloworld,\" + \"helloworld!helloworld,helloworld!\"); spannableString.setSpan(new VerticalImageSpan(drawable), 0, 1, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 字体多色渐变彩虹样的Span，其实实现起来也是很简单的，主要是用到了Paint的Shader技术，效果如下所示： 源代码如下所示：123456789101112131415private static class RainbowSpan extends CharacterStyle implements UpdateAppearance &#123; private final int[] colors; public RainbowSpan(Context context) &#123; colors = context.getResources().getIntArray(R.array.rainbow); &#125; @Override public void updateDrawState(TextPaint paint) &#123; paint.setStyle(Paint.Style.FILL); Shader shader = new LinearGradient(0, 0, 0, paint.getTextSize() * colors.length, colors, null, Shader.TileMode.MIRROR); Matrix matrix = new Matrix(); matrix.setRotate(90); shader.setLocalMatrix(matrix); paint.setShader(shader); &#125;&#125; 由于paint使用shader是从上到下进行绘制，因此这里需要用到矩阵，然后将矩阵旋转90度。 用法示例：1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); final SpannableString spannableString = new SpannableString( &quot;helloworld,helloworld!helloworld,helloworld!helloworld,&quot; + &quot;helloworld!helloworld,helloworld!&quot;); spannableString.setSpan(new RainbowSpan(this), 0, 40, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 字体多色渐变动画效果 如果要实现一个动画的彩虹样式，那么该如何实现呢？ 其实结合上面的RainbowSpan和AnimateForegroundColorSpan的例子便可以实现AnimatedRainbowSpan。 实现思路：通过ObjectAnimator动画调整RainbowSpan中矩阵的平移，从而实现动画彩虹的效果。 代码如下所示： 首先是AnimatedColorSpan1234567891011121314151617181920212223242526272829private static class AnimatedColorSpan extends CharacterStyle implements UpdateAppearance &#123; private final int[] colors; private Shader shader = null; private Matrix matrix = new Matrix(); private float translateXPercentage = 0; public AnimatedColorSpan(Context context) &#123; colors = context.getResources().getIntArray(R.array.rainbow); &#125; public void setTranslateXPercentage(float percentage) &#123; translateXPercentage = percentage; &#125; public float getTranslateXPercentage() &#123; return translateXPercentage; &#125; @Override public void updateDrawState(TextPaint paint) &#123; paint.setStyle(Paint.Style.FILL); float width = paint.getTextSize() * colors.length; if (shader == null) &#123; shader = new LinearGradient(0, 0, 0, width, colors, null, Shader.TileMode.MIRROR); &#125; matrix.reset(); matrix.setRotate(90); matrix.postTranslate(width * translateXPercentage, 0); shader.setLocalMatrix(matrix); paint.setShader(shader); &#125; &#125;&#125; 配合属性动画：1234567891011121314151617181920212223242526272829303132333435363738public class AnimatedRainbowSpanActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animated_rainbow_span); final TextView textView = (TextView) findViewById(R.id.text); String text = textView.getText().toString(); AnimatedColorSpan span = new AnimatedColorSpan(this); final SpannableString spannableString = new SpannableString(text); String substring = getString(R.string.animated_rainbow_span).toLowerCase(); int start = text.toLowerCase().indexOf(substring); int end = start + substring.length(); spannableString.setSpan(span, start, end, 0); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat( span, ANIMATED_COLOR_SPAN_FLOAT_PROPERTY, 0, 100); objectAnimator.setEvaluator(new FloatEvaluator()); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; textView.setText(spannableString); &#125; &#125;); objectAnimator.setInterpolator(new LinearInterpolator()); objectAnimator.setDuration(DateUtils.MINUTE_IN_MILLIS * 3); objectAnimator.setRepeatCount(ValueAnimator.INFINITE); objectAnimator.start(); &#125;private static final Property&lt;AnimatedColorSpan, Float&gt; ANIMATED_COLOR_SPAN_FLOAT_PROPERTY = new Property&lt;AnimatedColorSpan, Float&gt;(Float.class, \"ANIMATED_COLOR_SPAN_FLOAT_PROPERTY\") &#123; @Override public void set(AnimatedColorSpan span, Float value) &#123; span.setTranslateXPercentage(value); &#125; @Override public Float get(AnimatedColorSpan span) &#123; return span.getTranslateXPercentage(); &#125;&#125;; 打字效果 有了上面的例子，写TypeWriterSpan就变得十分简单了。 先创建TypeWriterSpanGroup1234567891011121314151617181920212223242526272829public class TypeWriterSpanGroup &#123; private final float mAlpha; private final ArrayList&lt;MutableForegroundColorSpan&gt; mSpans; public TypeWriterSpanGroup(float alpha) &#123; mAlpha = alpha; mSpans = new ArrayList&lt;MutableForegroundColorSpan&gt;(); &#125; public void addSpan(MutableForegroundColorSpan span) &#123; span.setAlpha((int) (mAlpha * 255)); mSpans.add(span); &#125; public void setAlpha(float alpha) &#123; int size = mSpans.size(); float total = 1.0f * size * alpha; for(int index = 0 ; index &lt; size; index++) &#123; MutableForegroundColorSpan span = mSpans.get(index); if(total &gt;= 1.0f) &#123; span.setAlpha(255); total -= 1.0f; &#125; else &#123; span.setAlpha((int) (total * 255)); total = 0.0f; &#125; &#125; &#125; public float getAlpha() &#123; return mAlpha; &#125;&#125; 然后添加Span与添加动画，整体使用示例如下：1234567891011121314151617181920212223242526@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextView tv = findViewById(R.id.id_tv_framespan); String val = \"helloworld,helloworld!helloworld,helloworld!helloworld\"; final SpannableString spannableString = new SpannableString(val); // 添加Span final TypeWriterSpanGroup group = new TypeWriterSpanGroup(0); for(int index = 0 ; index &lt;= val.length()-1 ; index++) &#123; MutableForegroundColorSpan span = new MutableForegroundColorSpan(); group.addSpan(span); spannableString.setSpan(span, index, index + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; // 添加动画 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(group, TYPE_WRITER_GROUP_ALPHA_PROPERTY, 0.0f, 1.0f); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //refresh tv.setText(spannableString); &#125; &#125;); objectAnimator.setDuration(5000); objectAnimator.start();&#125; 动画属性变化器代码如下：1234567891011private static final Property&lt;TypeWriterSpanGroup, Float&gt; TYPE_WRITER_GROUP_ALPHA_PROPERTY = new Property&lt;TypeWriterSpanGroup, Float&gt;(Float.class, \"TYPE_WRITER_GROUP_ALPHA_PROPERTY\") &#123; @Override public void set(TypeWriterSpanGroup spanGroup, Float value) &#123; spanGroup.setAlpha(value); &#125; @Override public Float get(TypeWriterSpanGroup spanGroup) &#123; return spanGroup.getAlpha(); &#125; &#125;; 涉及到的类：12345678910111213141516171819public class MutableForegroundColorSpan extends CharacterStyle implements UpdateAppearance &#123; public static final String TAG = \"MutableForegroundColorSpan\"; private int mColor = Color.BLACK; private int mAlpha = 0 ; @Override public void updateDrawState(TextPaint tp) &#123; tp.setColor(mColor); tp.setAlpha(mAlpha); &#125; public int getColor() &#123; return mColor; &#125; public void setColor(int color) &#123; this.mColor = color; &#125; public void setAlpha(int alpha) &#123; mAlpha = alpha; &#125;&#125;","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Android混淆总结","slug":"Android混淆总结","date":"2018-02-22T19:27:42.000Z","updated":"2018-02-22T12:01:56.000Z","comments":true,"path":"2018/02/23/Android混淆总结/","link":"","permalink":"http://yoursite.com/2018/02/23/Android混淆总结/","excerpt":"","text":"通过代码混淆可以将项目中的类、方法、变量等信息进行重命名，变成一些无意义的简短名字，同时也可以移除未被使用的类、方法、变量等。所以直观的看，通过混淆可以提高程序的安全性，增加逆向工程的难度，同时也有效缩减了apk的体积。 开启混淆在基于Android Studio项目的app module的build.gradle中有如下默认代码片段： 1234567buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; minifyEnabled true 代表要发布的release包的混淆配置，默认不开启混淆，设为true表示开启混淆。 shrinkResources true 代表开启资源文件压缩。 proguard-android.txt 代表系统默认的混淆规则配置文件，该文件在/tools/proguard下，一般不要更改该配置文件。 proguard-rules.pro 代表当前module的混淆配置文件，可以通过修改该文件来添加当前项目的混淆规则。 编写混淆配置文件以下是系统的proguard-android.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html# 混淆时不使用大小写混合类名-dontusemixedcaseclassnames# 不跳过library中的非public的类-dontskipnonpubliclibraryclasses# 打印混淆的详细信息-verbose# Optimization is turned off by default. Dex does not like code run# through the ProGuard optimize and preverify steps (and performs some# of these optimizations on its own).# 关闭优化（原因见上边的原英文注释）-dontoptimize# 不进行预校验，可加快混淆速度-dontpreverify# Note that if you want to enable optimization, you cannot just# include optimization flags in your own project configuration file;# instead you will need to point to the# \"proguard-android-optimize.txt\" file instead of this one from your# project.properties file.# 保留注解中的参数-keepattributes *Annotation*# 不混淆如下两个谷歌服务类-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# For native methods, see http://proguard.sourceforge.net/manual/examples.html#native# 不混淆包含native方法的类的类名以及native方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# keep setters in Views so that animations can still work.# see http://proguard.sourceforge.net/manual/examples.html#beans# 不混淆View中的setXxx()和getXxx()方法，以保证属性动画正常工作-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;# We want to keep methods in Activity that could be used in the XML attribute onClick# 不混淆Activity中参数是View的方法，例如，一个控件通过android:onClick=\"clickMethodName\"绑定点击事件，混淆后会导致点击事件失效-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations# 不混淆枚举类中的values()和valueOf()方法-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 不混淆Parcelable实现类中的CREATOR字段，以保证Parcelable机制正常工作-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;# 不混淆R文件中的所有静态字段，以保证正确找到每个资源的id-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# The support library contains references to newer platform versions.# Don't warn about those in case this app is linking against an older# platform version. We know about them, and they are safe.# 不对android.support包下的代码警告（如果我们打包的版本低于support包下某些类的使用版本，会出现警告的问题）-dontwarn android.support.**# Understand the @Keep support annotation.# 不混淆Keep类-keep class android.support.annotation.Keep# 不混淆使用了注解的类及类成员-keep @android.support.annotation.Keep class * &#123;*;&#125;# 如果类中有使用了注解的方法，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;# 如果类中有使用了注解的字段，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;# 如果类中有使用了注解的构造函数，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; keep关键字： 关键字 含义 keep 保留类和类成员，防止被混淆或移除 keepnames 保留类和类成员，防止被混淆，但没有被引用的类成员会被移除 keepclassmembers 只保留类成员，防止被混淆或移除 keepclassmembernames 只保留类成员，防止被混淆，但没有被引用的成员会被移除 keepclasseswithmembers 保留类和类成员，防止被混淆或移除，如果指定的类成员不存在还是会被混淆 keepclasseswithmembernames 保留类和类成员，防止被混淆，如果指定的类成员不存在还是会被混淆，没有被引用的类成员会被移除 相关通配符： 通配符 含义 * 匹配任意长度字符，但不含包名分隔符.。例如一个类的全包名路径是com.othershe.test.Person，使用com.othershe.test.、com.othershe.test.都是可以匹配的，但com.othershe.*就不能匹配 ** 匹配任意长度字符，并包含包名分隔符.。例如要匹配com.othershe.test.**包下的所有内容 * 匹配任意参数类型。例如 getName()可匹配String getName(String) … 匹配任意长度的任意类型参数。例如void setName(…)可匹配void setName(String firstName, String secondName) &lt;fileds&gt; 匹配类、接口中所有字段 &lt;methods&gt; 匹配类、接口中所有方法 &lt;init&gt; 匹配类中所有构造函数 以上就是混淆的基本语法，系统的proguard-android.txt已经为我们完成了大部分基础的混淆配置工作，至于编写当前app module下的proguard-rules.pro，只需要针对当前项目添加一些特有的配置，避免某些重要的东西被混淆掉就可以了，我们主要考虑以下几点： 在AndroidManifest.xml中注册的继承四大组件的子类的类名以及重写的方法名都不会被混淆。 比如，如果希望项目中android.support.v4.app.Fragment子类的类名和重写父类的方法名不被混淆可以添加如下配置12345# 不混淆Fragment的子类类名以及onCreate()、onCreateView()方法名-keep public class * extends android.support.v4.app.Fragment &#123; public void onCreate(android.os.Bundle); public android.view.View onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle);&#125; 不混淆某个特定的类和类中所有成员 1-keep class com.test.utils.CommonUtil &#123; *; &#125; 不混淆某个目录下的文件，例如使用Gson时，数据bean不能被混淆，需要如下配置： 12# com.test.bean代表所有bean所在的目录-keep class com.test.bean.** &#123; *; &#125; 保留泛型 1-keepattributes Signature 保留用于调试堆栈跟踪的行号信息 1-keepattributes SourceFile,LineNumberTable WebView中使用了JS调用，需要添加如下配置： 123-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125; 项目中使用的第三方库的混淆规则，这里列举几个常用的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# okhttp-dontwarn okhttp3.**-dontwarn okio.**-dontwarn javax.annotation.**-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase# Retrofit-dontwarn okio.**-dontwarn javax.annotation.**-dontnote retrofit2.Platform-dontwarn retrofit2.Platform$Java8-keepattributes Signature-keepattributes Exceptions# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Gson-keep class com.google.gson.stream.** &#123; *; &#125;-keepattributes EnclosingMethod# xxx代表model类的全包名路径-keep class xxx.** &#123; *; &#125;# butterknie-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# eventbus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; 查看混淆结果混淆后打包，会在app module/build/outputs/mapping/release目录下生成如下文件 dump.txt：描述apk文件中所有类的内部结构 mapping.txt：混淆前后的类、类成员、方法的对照关系（重要，追溯Crash堆栈信息要用到） resources.txt：资源文件的压缩信息 seeds.txt：未被混淆的类和成员 usage.txt：被移除的代码 最后还是有必要看一下混淆后的代码结构，验证混淆是否成功。一个简单的办法，Android Studio的Build菜单下有一个Analyze APK选项，只需要先选择要分析的apk包，在之后的界面点击classes.dex即可看到混淆后的代码结构： 如果看到a b c d e 这样的包名，说明已经混淆成功了。 追溯Crash信息代码混淆后，也会导致Crash堆栈信息被混淆，难以阅读，增加定位问题位置的难度，一个混淆后的Crash堆栈信息类似这样，核心的信息都没了： 为了解决这个问题，可以使用\\tools\\proguard\\bin下的proguardgui.bat脚本将Crash堆栈信息还原到混淆前的状态。步骤如下： 双击打开脚本，选择左边的ReTrace选项 选择Mapping file文件，也就是混淆后打包后在app module/build/outputs/mapping/release下生成的mapping.txt 拷贝混淆后的堆栈信息 点击右下角的ReTrace!按钮，完成Crash堆栈信息的追溯 如下图中间部分就是追溯到的原Crash堆栈信息： 代码混淆基本的内容就这些了。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"给RecyclerView加上折叠的效果","slug":"给RecyclerView加上折叠的效果","date":"2018-02-22T15:37:21.000Z","updated":"2018-02-22T11:13:36.000Z","comments":true,"path":"2018/02/22/给RecyclerView加上折叠的效果/","link":"","permalink":"http://yoursite.com/2018/02/22/给RecyclerView加上折叠的效果/","excerpt":"","text":"RecyclerView 有很高的自由度，可以说只有想不到没有做不到。这次用超简单的方法，让 RecyclerView 带上折叠的效果。 效果是这样的。 总结一下这个列表的特点，就是以下三点： 重叠效果； 层次感； 首项的差动。下面我们来一个个解决。 我们新建一个 ParallaxRecyclerView，让它继承 RecyclerView，并使用 LinearLayoutManager 作为布局管理器。 重叠效果 其实就是每一项都搭一部分在它前面那项而已。我们知道，RecyclerView 可以通过设置 ItemDecoration来实现列表的间隔效果，有没有想过要是把间隔设为负数会怎么样？比如： 1234567addItemDecoration(new ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom = -dp2px(context, 10); &#125; &#125;); 没错，这就实现了我们的重叠效果。 层次感 在 Material Design里是有Z轴这个概念的，我们可以给控件设置垂直于屏幕的高度，让不在同一高度的控件看起来有层次感。当然，我们要用 Material Design 的控件才有这个属性，这里我用的是 CardView。 我们给 ParallaxRecyclerView 增加一个滑动监听，在 onScrolled 方法里面做如下设置： 12345678910111213141516LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();int firstPosition = layoutManager.findFirstVisibleItemPosition();int lastPosition = layoutManager.findLastVisibleItemPosition();int visibleCount = lastPosition - firstPosition;//重置控件的高度int elevation = 1;for (int i = firstPosition - 1; i &lt;= (firstPosition + visibleCount) + 1; i++) &#123; View view = layoutManager.findViewByPosition(i); if (view != null) &#123; if (view instanceof CardView) &#123; ((CardView) view).setCardElevation(dp2px(context, elevation)); elevation += 5; &#125; &#125;&#125; 其中，setCardElevation 方法就是用来给 CardView 设置高度的，这里让每一项的高度比它的上一项高 5dp。 首项的差动 最后，我们想给第一项增加一个差动效果，这个同样在 onScrolled方法里面做处理就好了： 123View firstView = layoutManager.findViewByPosition(firstPosition);float firstViewTop = firstView.getTop();firstView.setTranslationY(-firstViewTop / 2.0f); 这样相当于第一项的滑动速度变成原来的一半。但这也会导致一个问题， 由于改变了控件的位置，当这个控件被复用时，会出现位置不正确的情况。所以我们在设置高度的时候，可以顺便把控件的位置复原了： 1234float translationY = view.getTranslationY();if (i &gt; firstPosition &amp;&amp; translationY != 0) &#123; view.setTranslationY(0);&#125; 这样就完成了一个带有简单折叠效果的 RecyclerView 了，妥妥的。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Android性能优化","slug":"Android性能优化","date":"2018-02-22T14:06:01.000Z","updated":"2018-02-22T12:36:02.000Z","comments":true,"path":"2018/02/22/Android性能优化/","link":"","permalink":"http://yoursite.com/2018/02/22/Android性能优化/","excerpt":"","text":"Android性能优化，是Android开发中的重中之中，本文将讲述如何进行性能优化。 实际项目中的Android性能优化主要有如下几个方面： 编写高效代码—开发中总结出的一些小的性能Tips Layout布局优化 内存优化 编写高效代码编写高效代码的两个原则 不要写不需要的代码 不要分配不必要的内存 以上两个原则，似乎感觉是废话，但确实是编程的最高境界，也是我们编写代码的过程中时刻需要思考和注意的两个方面。 那么如何做到如上两点呢？下面列出了一些实际开发中的例子。 避免产生不必要的对象 例如： int的数组比Integer对象数组要好得多。两个平行的int数组要比一个（int,int）型的对象数组高效。这对于其他任何基本数据类型的组合都通用 两个平行数组Foo[],Bar[]会优于一个（Foo,Bar）对象的数组 通常来讲，尽量避免创建短时零时对象.少的对象创建意味着低频的垃圾回收 对象的分配和回收都是需要代价的；分配的内存越多，就会引起强制的内存回收；给用户体验增加小的停顿间隙，从而影响用户体验。 用户能感觉到卡顿的时间延迟是100ms ~ 200ms。 用静态代替虚拟 如果方法不需要访问某对像的字段，将该方法设置为静态，调用速度会提升15%~20% 对于常量使用static final static final int i = 1;static final String s = “a”; 注：这种优化仅仅是针对基本数据类型和String类型常量的，而非任意的引用类型。但尽可能的将常量声明为static final是一种好的做法。 避免内部的getter和setter 使用增强for循环 增强for循环要比普通循环快3倍 避免使用浮点数 通常，浮点数会比整型慢2/3 在没有JIT的设备上，调用方法所传递的对象采用具体的类型而非接口类型会更高效 void methodA(List list); void methodA(ArrayList list); 如上，后一种比前一种更高效。 数据库操作方法的优化尽量利用原生的SQL语句 原生的SQL省去了拼接sql语句的步骤，要比SqliteDatabase提供的insert、query、 update、delete等函数效率高。当数据库越大，差别也越大 当操作条数较多时，利用事务进行批处理 这样SQLite将把全部要执行的SQL语句先缓存在内存当中，然后等到COMMIT的时候一次性的写入数据库，这样数据库文件只被打开关闭了一次，效率自然大大的提高 12345db.beginTransaction(); for(Collection c:colls)&#123; insert(db, c);&#125; db.setTransactionSuccessful(); Http请求方式的选择Android 内置了两种HTTP方式:HttpURLConnection 和 Apache HttpClient。这两种都支持HTTPS、流式上传和下载、可配置超时、IPv6和连接池。在Gingerbread或者更高版本时，推荐使用HttpURLConnection。 这是因为： HttpURLConnection API 更简单，包更小。同时对传输数据的压缩和响应的缓存处理减少了网络带宽、提高了速度，也节省了电量。 优化布局Layouts是Android应用里直接影响用户体验的一个关键部分。如果Layout设计的不好，可能导致你的应用大量的内存占用从而导致UI响应很慢。Android SDK提供了工具帮助你分析你的Layouts的性能问题。 使用Hierarchy Viewer Hierarchy Viewer工具位于SDK \\tools\\目录下，该工具能分析出你的布局不合理和可以优化的地方。 大多数情况下，布局渲染时间差别较大的原因是在LinaerLayout里使用了layout_weight。这将会增加测量(Measure)的时间。你应该仔细的考虑是否有必要使用layout weight。 使用Lint 使用Lint — 查看你的view层级哪些地方可以优化 使用compound drawables - 一个包含了ImageView与TextView的LinearLayout可以被当作一个compound drawable来处理 使用 - 如果FramLayout仅仅是一个纯粹的（没有设置背景，间距等）布局根元素，我们可以使用merge标签来当作根标签 无用的分支 - 如果一个layout并没有任何子组件，那么可以被移除，这样可以提高效率 无用的父控件 - 如果一个layout只有子控件，没有兄弟控件，并且不是一个ScrollView或者根节点，而且没有设置背景，那么我们可以移除这个父控件，直接把子控件提升为父控件 深层次的layout - 尽量减少内嵌的层级，考虑使用更多平级的组件 RelativeLayout or GridLayout来提升布局性能，默认最大的深度是10 其他一些布局要点 使用include标签 使用ViewStub标签 优化App内存为了垃圾回收器能回收你系统的内存，你应该避免引起内存泄露，而且要在合适的时间点释放被引用的对象。 慎用Service Service执行完后台任务后要停止 使用IntentService IntentService不同于普通的Service之处是： 提交的task系统会post到子线程运行 当后台运行的task完成时，系统会stop掉IntentService Release memory when your user interface becomes hidden 例如，在该onStop（）里做释放资源（例如网络连接、注销广播等）的工作 使用优化后的集合容器 例如：SparseArray、SparseBooleanArray、LongSpareArray ….. 尽量避免使用枚举 相比于静态常量，枚举会有超过其两倍以上的内存开销，在android中需严格避免使用枚举 避免使用依赖注入框架 使用ProGuard消除没有使用的代码 使用zipalign优化和对齐你的apk 使用MAT分析和优化内存 I/O使用后需要关闭，数据库和Cursor等使用后要关闭 使用finalize()+MAT 分析内存泄露 end Android优化主要就是内存、布局和性能的优化，本文总结了Android中优化的一些知识点。如果还有其他我没有讲到的，欢迎给我留言。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"http和https","slug":"http和https","date":"2018-02-21T16:33:46.000Z","updated":"2018-02-22T11:14:14.000Z","comments":true,"path":"2018/02/22/http和https/","link":"","permalink":"http://yoursite.com/2018/02/22/http和https/","excerpt":"","text":"HTTP基础 超文本传输协议（HTTP，HyperText Transfer Protocol），默认端口：80 特点 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 请求报文 一般由请求行、请求头、空行、请求体四部分组成。 响应报文 一般由状态行、消息报头、空行、响应正文四部分组成。 常见状态码 200 OK：客户端请求成功 302 Move temporarily：请求的资源临时从不同的 URI响应请求，重定向 304 Not Modified：有效缓存 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现 500 Internal Server Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 常见通用报头 Cache-Control：指定请求和响应遵循的缓存机制 常用请求报头 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接 Referer：允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等 Range：可以请求实体的一个或者多个子范围 常见响应报头 Location：用于重定向接受者到一个新的位置，常用在更换域名的时候Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的 常见实体报头 Content-Type：发送给接收者的实体正文的媒体类型 Content-Lenght：实体正文的长度 Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制 Last-Modified：实体报头用于指示资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间 SPDY 2012年google提出的SPDY方案，主要解决： 降低延迟：SPDY采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式； 请求优先级：SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应； header压缩：选择合适的压缩算法可以减小包的大小和数量； 基于HTTPS的加密协议传输 服务端推送 Http2.0 可以看成是SPDY的升级版。 Http2.0与SPDY的区别 HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE Http2.0新特性 新的二进制格式：HTTP1.x的解析是基于文本的 多路复用：即连接共享，即每一个request都是是用作连接共享机制的 header压缩 服务端推送 HTTPS (Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，即HTTP下加入SSL层，端口：443 HTTPS握手流程 客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息； 服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书； 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步； 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器； 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器； 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）； 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化； 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束； 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束； SSL 的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 Android中处理Https处理 javax.net.ssl.SSLHandshakeException: 证书验证失败 123456789101112131415161718192021222324252627282930313233343536/** * HTTPS未知的证书颁发机构处理方法 * Android客户端存储证书 * * @param input 待信任的CA证书流 * @return SSLContext */public static SSLContext getSSLContext(InputStream input) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); Certificate ca = cf.generateCertificate(input); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setCertificateEntry(\"ca\", ca); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(keyStore); sslContext.init(null, tmf.getTrustManagers(), null); input.close(); return sslContext; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null;&#125; 单独使用SSL和HTTP 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 单独使用SSL + HTTP时 * @param trustManagers * @return */public static SSLContext getSSLContext(TrustManager[] trustManagers) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagers, null); return sslContext; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static TrustManager[] sDefaultTrustManagers = new TrustManager[] &#123;new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; // TODO: 2018/1/23双向校验中，向服务端发客户端证书 &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; // TODO: 2018/1/23 双向校验中，校验服务端证书 &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125;&#125;&#125;;public static HostnameVerifier sHostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; // 不验证主机名 return true; &#125;&#125;;","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"实现上滑屏幕，隐藏底部菜单栏","slug":"实现上滑屏幕，隐藏底部菜单栏","date":"2018-02-08T22:02:50.000Z","updated":"2018-02-22T12:36:29.000Z","comments":true,"path":"2018/02/09/实现上滑屏幕，隐藏底部菜单栏/","link":"","permalink":"http://yoursite.com/2018/02/09/实现上滑屏幕，隐藏底部菜单栏/","excerpt":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。","text":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。本文主要实现的功能是底部菜单栏随用户手势滑动而变化。 正常状态 上滑之后 布局代码这个功能实现起来比较简单，主要利用了CoordinatorLayout的layout_behavior的属性。具体代码如下： 123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/toolbar\"/&gt; &lt;include layout=\"@layout/container\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/bottom_navigation\" style=\"@style/Widget.Design.BottomNavigationView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_gravity=\"bottom\" android:background=\"@color/viewBackground\" app:elevation=\"16dp\" app:itemIconTint=\"@drawable/nav_item_color_state\" app:itemTextColor=\"@drawable/nav_item_color_state\" app:layout_behavior=\"com.testapp.widget.behavior.BottomNavigationBehavior\" app:menu=\"@menu/bottom_navigation_main\"/&gt; 上面是activity_main的布局代码，第一个是菜单栏，第二个是内容界面，第三个是bottom。bottom导航栏这里采用是BottomNavigationView，具体用法不再介绍。这里主要看一下BottomNavigationView的app:layout_behavior属性，该属性是协调布局特有的。网上的一版用法是 1app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" 虽然表面上看是一个字符串，其实在里面调用的也是一个view类。这次我们通过自定义这个behavior类，实现底部菜单栏的显隐性。 java实现类1234567891011121314151617181920212223242526272829303132333435public class BottomNavigationBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private ObjectAnimator outAnimator, inAnimator; public BottomNavigationBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; // 垂直滑动 @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0) &#123;// 上滑隐藏 if (outAnimator == null) &#123; outAnimator = ObjectAnimator.ofFloat(child, \"translationY\", 0, child.getHeight()); outAnimator.setDuration(200); &#125; if (!outAnimator.isRunning() &amp;&amp; child.getTranslationY() &lt;= 0) &#123; outAnimator.start(); &#125; &#125; else if (dy &lt; 0) &#123;// 下滑显示 if (inAnimator == null) &#123; inAnimator = ObjectAnimator.ofFloat(child, \"translationY\", child.getHeight(), 0); inAnimator.setDuration(200); &#125; if (!inAnimator.isRunning() &amp;&amp; child.getTranslationY() &gt;= child.getHeight()) &#123; inAnimator.start(); &#125; &#125; &#125;&#125; 这个类的就是刚刚那个app:layout_behavior=”com.meiji.toutiao.widget.behavior.BottomNavigationBehavior”属性标明的类，看起来很简单，继承了Behavior抽象类，然后实现了两个方法。 onStartNestedScroll：这个方法主要用于监听协调布局的子view的滚动事件，当此方法返回true，表示要消耗此动作，继而执行下面的onNestedPreScroll方法，我们在代码中返回的是，滚动轴是不是竖直滚动轴。如果是的话，就返回trueonNestedPreScroll：这个方法就比较简单了，当用户上滑的时候，隐藏底部菜单栏，这里使用了动画退出，使用了ObjectAnimator.ofFloat方法，第一个是view对象，指的就是bottom，第二个是Y轴的变化，第三个是Y轴变化的多少，接下来设置动画秒数。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"通过H5唤起本地app","slug":"通过H5唤起本地app","date":"2018-02-05T21:33:43.000Z","updated":"2018-02-08T14:01:16.000Z","comments":true,"path":"2018/02/06/通过H5唤起本地app/","link":"","permalink":"http://yoursite.com/2018/02/06/通过H5唤起本地app/","excerpt":"在安卓手机的浏览器中调起本地app","text":"在安卓手机的浏览器中调起本地appH5如何打开或者说唤起手机本地的app，有以下两种： 第一种方式： 通过在html的a标签里面的href中直接配置android端的schema，当然，如果有host其他的配置，跟在后面就可以了，android端配置和代码如下： android端配置：12345678910111213&lt;activity android:name = \".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name = \"android.intent.action.MAIN\"/&gt; &lt;category android:name = \"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;data android:host=\"baidu.com\" android:scheme=\"testapp\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 注：如果这个是配置在启动页要和标签并列在一起，不然运行后手机app的图标会没有；注意schema协议要小写,否则会有不能响应的异常! html代码： 123456789&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"testapp://baidu.com/?pid=1\"&gt;打开app&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 这里我们来看看schema拼接协议的格式： &lt; a href=”[scheme]://[host]/[path]?[query]”&gt;启动应用程序&lt; /a&gt; 各个项目含义如下所示： scheme：判别启动的App。 host：适当记述 path：传值时必须的key ※没有也可以 query：获取值的Key和Value ※没有也可以 以上就能实现打开本地的app了，当然是在app存在的情况下，否则的话没有反应。 我们有些时候在唤起本地app的时候可能会向app传递一些参数，这些参数我们就可以配置在path或者query里，我们只需要在oncreate里面获取就可以了。 代码如下： 12345Intent intent = getIntent(); Uri uri = intent.getData(); if (uri != null) &#123; String pid = uri.getQueryParameter(\"pid\");&#125; 如果还想要获取android里面配置的schema协议的话，还可以这样: 12345678910111213141516171819202122232425Uri uri = getIntent().getData();if(uri != null) &#123; // 完整的url信息 String url = uri.toString(); Log.e(TAG, \"url: \" + uri); // scheme部分 String scheme = uri.getScheme(); Log.e(TAG, \"scheme: \" + scheme); // host部分 String host = uri.getHost(); Log.e(TAG, \"host: \" + host); //port部分 int port = uri.getPort(); Log.e(TAG, \"host: \" + port); // 访问路径 String path = uri.getPath(); Log.e(TAG, \"path: \" + path); List&lt;String&gt; pathSegments = uri.getPathSegments(); // Query部分 String query = uri.getQuery(); Log.e(TAG, \"query: \" + query); //获取指定参数值 String pid = uri.getQueryParameter(\"pid\"); Log.e(TAG, \"pid: \" + pid);&#125; 如何判断一个Schema是否有效 : 1234567PackageManager packageManager = getPackageManager();Intent intent = newIntent(Intent.ACTION_VIEW, Uri.parse(\"testapp://baidu.com:80/article?goodsId=10011002\"));List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(intent, 0);booleanisValid = !activities.isEmpty();if(isValid) &#123; startActivity(intent);&#125; 这种方式也是我百度到的最多的方式，但是这样就带来了一个问题了，上面的需求说的是“在页面上有一个连接， 如果用户安装了APP，则点击打开对应的APP；如果用户没有安装，则点击打开对应的设置连接”，这明显就不符合需求了，这只能作为一些个别需求来使用了。 第二种方式： 既然通过在href配置schema协议不行，那就只能通过js代码来实现了，只有这样才能根据判断实现app有的时候就打开，没有的时候就跳转到下载链接下载。 我们知道，js是无法判断手机是否安装了某款app的，所以我们只能够曲线救国了，我们可以获取时间如果，长时间不能呼起app则默认为没有安装这款app，然后跳转到下载页。当然这不是我想出来的，是网上的各位大佬的想法。在这里又要细分为两种情况了。 1.直接唤醒 说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式兼容性较好，如果安装了app，在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器、QQ浏览器、百度浏览器 )和QQ客户端中，能唤醒。微信、新浪微博客户端、腾讯微博客户端无法唤醒。 代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;点击唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式。兼容性较好，如果安装了app，在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )和QQ客户端中，能唤醒。微信 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;a href=\"zjmobile://platformapi/startapp\" id=\"zjmobliestart\" target=\"_blank\"&gt;唤醒浙江移动手机营业厅！&lt;/a&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; return function()&#123; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;; &#125;applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.点击唤醒 说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面。兼容性一般：在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器 QQ浏览器、百度浏览器 )能唤醒。微信、QQ客户端、新浪微博客户端、 腾讯微博客户端无法唤醒。 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;直接唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面兼容性一般：在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )能唤醒。微信 QQ客户端 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;p id=\"zjmobliestart\"&gt;唤醒浙江移动手机营业厅！&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; window.location = 'zjmobile://platformapi/startapp'; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;document.getElementById(\"zjmobliestart\").onclick = applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样就完成了我们的需求了。 还要注意的是，如果是在微信中唤起本地app，手机的微信中，是利用微信内置的浏览器打开那个简单的HTML页面，注意：直接打开scheme://host/datastring是不可行的，微信不会把这串字符解析成网址，必须包装成网页才能借助微信的浏览器打开。进入后就是我们刚刚设计的页面。这个时候，直接点击“启动应用程序”是不会唤醒之前安装的APP的，因为微信做了屏蔽，你需要在右上角的菜单中选择“在浏览器中打开”。这个时候就可以唤醒你想唤醒的app了。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]}]}