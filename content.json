{"meta":{"title":"郑林飞","subtitle":null,"description":null,"author":"郑林飞","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-04-14T08:45:16.000Z","updated":"2018-04-14T08:45:16.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-03-03T14:59:06.000Z","updated":"2018-03-03T14:59:06.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的秘密","date":"2018-04-14T16:47:07.000Z","updated":"2018-04-14T12:02:41.000Z","comments":true,"path":"list/index.html","permalink":"http://yoursite.com/list/index.html","excerpt":"","text":"1、 面试题 2、 慕课网笔记 3、 测试 4、 面试题"},{"title":"面试题","date":"2018-03-03T19:16:04.000Z","updated":"2018-03-03T14:05:45.000Z","comments":true,"path":"ms/index.html","permalink":"http://yoursite.com/ms/index.html","excerpt":"","text":"AndroidAndroid的四大组件是哪些，它们的作用？Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑；Service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事务，定义好需要接收的Intent提供同步和异步的接口；ContentProvider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提供了更方便的途径；BroadcastReceiver：接收一种或者多种Intent作触发事件，接收相关消息转换成一条Notification，统一了Android的事件广播模型。 Activity的生命周期?onCreate() - onStart() - onResume() - onPause() - onstop() - onDestroy() - onRestart() 后台的Activity被系统回收怎么办?onSaveInstanceState()123456789protected void onSaveInstanceState(BundleoutState) &#123; super.onSaveInstanceState(outState); outState.putLong(\"id\",1234567890); &#125; public void onCreate(BundlesavedInstanceState) &#123; //判断savedInstanceState是不是空. //如果不为空就取出来 super.onCreate(savedInstanceState); &#125; android 横竖屏切换生命周期?不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 什么是ANR，如何避免它?用户操作在5秒内应用程序未做出响应，或者BroadcastReceiver在10秒内没有执行完毕。 Android的系统架构?Android系统架构从上往下为Linux内核层、运行库、应用程序框架层、应用程序层。 谈谈Android的IPC（进程间通信）机制?Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互。 如何将SQLite数据库与apk文件一起发布?可以将db文件复制到工程中的res\\raw目录中，raw中的文件不会被压缩。 常用到的设计模式? 单例模式 懒汉式 123456789101112//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125; &#125; 饿汉式 123456789//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton &#123; private Singleton() &#123;&#125; private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() &#123; return single; &#125; &#125; 适配器模式 观察者模式 建造者模式 4种启动模式? standard：默认 singleTop：如果有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。 singleTask：如果有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象。 singleInstance：启用一个新的栈， Service的两种启动方式?第一种：startService 1.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的startService(Intent)方法启动该Service4.不再使用时，调用stopService(Intent)方法停止该服务 使用这种start方式启动的Service的生命周期如下：onCreate() —&gt; onStartCommand()（onStart()方法已过时） —&gt; onDestory()。如果服务已经开启，不会重复的执行onCreate()，而是会调用onStart()和onStartCommand()。服务停止的时候调用 onDestory()。服务只会被停止一次。特点：一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。 第二种：bindService 1.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的bindService(Intent, ServiceConnection, int)方法启动该Service4.不再使用时，调用unbindService(ServiceConnection)方法停止该服务 使用这种start方式启动的Service的生命周期如下：onCreate() —&gt; onBind() —&gt; onunbind() —&gt; onDestory()特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。 两种注册、发送广播的方式?第一种：代码中动态注册123456789//new出上边定义好的BroadcastReceiverMyBroadCastReceiver yBroadCastReceiver = new MyBroadCastReceiver();//实例化过滤器并设置要过滤的广播 IntentFilter intentFilter = new IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\");//注册广播 myContext.registerReceiver(smsBroadCastReceiver,intentFilter, \"android.permission.RECEIVE_SMS\", null); 第二种：Manifest.xml中静态注册123456&lt;receiver android:name=\".MyBroadCastReceiver\"&gt; &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt; &lt;intent-filter android:priority=\"20\"&gt; &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 两种注册广播的不同第一种不是常驻型广播，也就是说广播跟随程序的生命周期。第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。有两种方式分别发送两种不同的广播：通过mContext.sendBroadcast(Intent)或mContext.sendBroadcast(Intent, String)发送的是无序广播(后者加了权限)；通过mContext.sendOrderedBroadcast(Intent, String, BroadCastReceiver, Handler, int, String, Bundle)发送的是有序广播。 HTTPS和HTTP的区别?HTTPS = HTTP + SSLHTTP 和 HTTPS 的不同之处 HTTP 是不安全的，而 HTTPS 是安全的 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层 HTTP 无需加密，而 HTTPS 对传输的数据进行加密 HTTP 无需证书，而 HTTPS 需要认证证书 排序算法(选择，冒泡)一：冒泡排序 基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。过程：比较相邻的两个数据，如果第二个数小，就交换位置。从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。继续重复上述过程，依次将第2.3…n-1个最小数排好位置。 123456789101112public static void sort(int[] arr) &#123; int temp;//临时变量 for (int i = 0; i &lt; arr.length - 1; i++) &#123;//表示趟数，一共arr.length-1次。 for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125;&#125; 二：选择排序基本思想：在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换；第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。 过程： 123456789101112131415public static void sort(int array[]) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125;&#125; 5种进程的优先级? 空进程 后台进程 服务进程 可见进程 前台进程 FragmentPageAdapter和FragmentPageStateAdapter的区别 FragmentPageAdapter在每次切换页面的的时候，是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响。 FragmentPageStateAdapter在每次切换页面的时候，是将Fragment进行回收，适合页面较多的Fragment使用，这样就不会消耗更多的内存。 JavaSwitch能否用string做参数？在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。 equals与==的区别?==比较的是2个对象的地址，而equals比较的是2个对象的内容。 String、StringBuffer与StringBuilder的区别? StringBuilder：线程非安全的 、StringBuffer：线程安全的a.如果要操作少量的数据用 = Stringb.单线程操作字符串缓冲区 下操作大量数据 = StringBuilderc.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer Collection与Collections的区别?Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。Collection是个java.util下的接口，它是各种集合结构的父接口。 Override和Overload的含义去区别?Overload：函数里面有相同的函数名但是参数名、返回值、类型不相同。Override：在子类继承父类的时候，将方法继承过来。 interface与abstract类的区别? 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的。 抽象类中可以包含静态方法，接口中不能包含静态方法。 一个类可以实现多个接口，但只能继承一个抽象类。 都不能被实例化。 接口里只能定义常量，不能定义普通成员变量；抽象类里则即可以定义普通成员变量，也可以定义静态常量。 解析XML的几种方式?DOM、SAX、PULL 设计模式六大原则? 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 迪米特法则 合成复用原则"},{"title":"慕课网笔记","date":"2018-04-14T17:19:02.000Z","updated":"2018-04-14T11:55:54.000Z","comments":true,"path":"imooc/index.html","permalink":"http://yoursite.com/imooc/index.html","excerpt":"","text":"1. APP性能优化之内存优化 2. APP性能优化之内存优化 3. APP性能优化之内存优化 4. APP性能优化之内存优化"},{"title":"Tags","date":"2018-03-03T14:59:11.000Z","updated":"2018-03-03T14:59:11.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android运行时权限详解","slug":"Android运行时权限详解","date":"2018-01-11T12:38:09.000Z","updated":"2018-02-24T02:12:21.000Z","comments":true,"path":"2018/01/11/Android运行时权限详解/","link":"","permalink":"http://yoursite.com/2018/01/11/Android运行时权限详解/","excerpt":"","text":"Android系统权限Android 是一个权限分隔的操作系统，其中每个应用都有其独特的系统标识（Linux 用户 ID 和组 ID）。系统各部分也分隔为不同的标识。Linux 据此将不同的应用以及应用与系统分隔开来。在默认情况下任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用程序的文件、执行网络访问、使设备保持唤醒状态等。 在旧的权限管理系统中，权限仅仅在App安装时询问用户一次，用户同意了这些权限App才能被安装，App一旦安装后后授权不可取消。 Android6.0引入了新的权限模式，将系统权限区分为正常权限和危险权限。开发者在使用到危险权限相关的功能时，不仅需要在Manifest文件中配置，还需要在代码中动态获取权限，如果没有确认获取到权限而直接执行相应所需权限的代码，将导致App崩溃。另外，Android6.0 以上系统,App 退到后台，修改应用权限，再次 App 回到前台，会出现应用新开进程重启。 权限的使用Android App 默认无任何权限，如果需要使用系统权限必须在AndroidManifest.xml文件中声明权限。1234567891011//声明网络使用权限&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.permission\"&gt;&lt;uses-permission android:name=\"android.permission.INTERNE\"/&gt; &lt;application ...&gt; ...&lt;/application&gt;&lt;/manifest&gt; 如果所需权限为正常权限（即不会对用户隐私或设备操作造成很大风险的权限），系统会自动授予这些权限。 如果所需权限为危险权限（即可能影响用户隐私或设备正常操作的权限），系统会要求用户明确授予这些权限。Android 发出请求的方式取决于系统版本(即targetSdkVersion)： 如果运行在 Android 6.0 及以上版本，App targetSdkVersion 大于23，则需要在运行时向用户请求权限，并且需要在 App 使用相关的权限之前检查自身是否已被授予该权限。 如果运行在 Android 6.0 以下版本，或App targetSdkVersion 小于23（此时设备可以是Android 6.0 (API level 23)或者更高），则系统会在用户安装则系统会在用户安装App时要求用户授予权限，系统就告诉用户App需要什么权限组。如果App将新权限添加到更新的应用版本，系统会在用户更新应用时要求授予该权限。用户一旦安装应用，他们撤销权限的唯一方式是卸载应用。正常权限正常权限涵盖应用需要访问其沙盒外部数据或资源，但对用户隐私或其他应用操作风险很小的区域。例如，设置时区的权限就是正常权限。此类权限都是正常保护的权限，只需要在Manifest文件中简单声明，安装即授权。 ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR UNINSTALL_SHORTCUT USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS危险权限 危险权限涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。例如，能够读取用户的联系人属于危险权限。 CALENDAR READ_CALENDAR WRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATE READ_PHONE_NUMBERS CALL_PHONE ANSWER_PHONE_CALLS (must request at runtime) READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS STORAGE READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 特殊权限有许多权限其行为方式与正常权限及危险权限都不同。SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 特别敏感，因此大多数应用不应该使用它们。如果某应用需要其中一种权限，必须在清单中声明该权限，并且发送请求用户授权的 intent。系统将向用户显示详细信息，以响应该 intent。 权限组所有危险权限都拥有对应权限组，如果运行在 Android 6.0 及以上版本，App targetSdkVersion 大于23，则当用户请求危险权限时系统会发生以下行为： 如果应用未拥有Manifest列出的危险权限所在的权限组任一权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。 如果应用已拥有Manifest列出的危险权限所在的权限组其他任一权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。 Android O的运行时权限策略变化 在 Android O 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。 例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。 我们申请了WRITE_EXTERNAL_STORAGE权限，在Android O之前，我们同时会得到READ_EXTERNAL_STORAGE权限，我们在其它地方涉及到读取存储卡的操作时只需要判断有WRITE_EXTERNAL_STORAGE权限就去读取了。此时应用如果安装在Android O的系统中我们会发现，判断了有WRITE_EXTERNAL_STORAGE权限后去读取存储卡内容时应用崩溃了，原因就是我们没有申请READ_EXTERNAL_STORAGE权限。 运行时请求权限检查权限及兼容(1)对于运行在 Android 6.0及以上 App targetSdkVersion 大于23的应用 如果App需要用到危险权限，需要这一权限的操作时都必须检查自己是否拥有该权限。 1int permissionCheck = ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.WRITE_CALENDAR); 如果应用已经具有了该权限,此方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，此时应用应当进行权限申请。 (2)对于运行在 Android 6.0及以上 App targetSdkVersion 大于23的应用 在App安装时会询问AndroidManifest.xml文件中的权限,用户也可以在设置列表中手动关闭/开启相关权限。 (3)对于运行在 Android 6.0以下 App targetSdkVersion 大于23的应用 对于运行在 Android 6.0以下 App targetSdkVersion 大于23的应用，默认情况下是会采取旧的权限机制，然而，一些国产手机在6.0之前就引入了权限管理系统，所以必须对其进行兼容。 下面我们来看ActivityCompat.requestPermissions()方法。 12345678910111213141516171819202122232425public static void requestPermissions(final @NonNull Activity activity, final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode) &#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; ActivityCompatApi23.requestPermissions(activity, permissions, requestCode); &#125; else if (activity instanceof OnRequestPermissionsResultCallback) &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; final int[] grantResults = new int[permissions.length]; PackageManager packageManager = activity.getPackageManager(); String packageName = activity.getPackageName(); final int permissionCount = permissions.length; for (int i = 0; i &lt; permissionCount; i++) &#123; grantResults[i] = packageManager.checkPermission( permissions[i], packageName); &#125; ((OnRequestPermissionsResultCallback) activity).onRequestPermissionsResult( requestCode, permissions, grantResults); &#125; &#125;); &#125;&#125; 系统版本小于23时，使用packageManager.checkPermission()对权限进行校验，而当App在AndroidManifest.xml中声明权限时，会返回PERMISSION_GRANTED，显然，这一校验方法在Android 6.0以下将失效。 PermissionChecker.checkSelfPermission()PermissionChecker是 Support V4 包下一个专门检查权限的工具类 123456789101112131415161718192021222324public static int checkPermission(@NonNull Context context, @NonNull String permission, int pid, int uid, String packageName) &#123; if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) &#123; return PERMISSION_DENIED; &#125; String op = AppOpsManagerCompat.permissionToOp(permission); if (op == null) &#123; return PERMISSION_GRANTED; &#125; if (packageName == null) &#123; String[] packageNames = context.getPackageManager().getPackagesForUid(uid); if (packageNames == null || packageNames.length &lt;= 0) &#123; return PERMISSION_DENIED; &#125; packageName = packageNames[0]; &#125; if (AppOpsManagerCompat.noteProxyOp(context, op, packageName) != AppOpsManagerCompat.MODE_ALLOWED) &#123; return PERMISSION_DENIED_APP_OP; &#125; return PERMISSION_GRANTED;&#125; checkSelfPermission通过上述四个判断语句进行权限校验 context.checkPermission()实际上调用的还是上述packageManager.checkPermission()方法进行校验。 AppOpsManagerCompat.permissionToOp()调用了IMPL.permissionToOp(permission)方法 12345678private static final AppOpsManagerImpl IMPL;static &#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; IMPL = new AppOpsManager23(); &#125; else &#123; IMPL = new AppOpsManagerImpl(); &#125;&#125; 可以看到，在Android6.0以下设备中，会使用AppOpsManagerImpl,其permissionToOp()方法进行权限检查，其默认返回null,所以PermissionChecker.checkSelfPermission() 同样会失效。 12345678910111213141516private static class AppOpsManagerImpl &#123; AppOpsManagerImpl() &#123; &#125; public String permissionToOp(String permission) &#123; return null; &#125; public int noteOp(Context context, String op, int uid, String packageName) &#123; return MODE_IGNORED; &#125; public int noteProxyOp(Context context, String op, String proxiedPackageName) &#123; return MODE_IGNORED; &#125;&#125; 此外，Google官方还提供了AppOpsManager类来检查权限 12345678910111213141516public int checkOp(String op, int uid, String packageName) &#123; return checkOp(strOpToOp(op), uid, packageName);&#125;@hide public int checkOp(int op, int uid, String packageName) &#123; try &#123; int mode = mService.checkOperation(op, uid, packageName); if (mode == MODE_ERRORED) &#123; throw new SecurityException(buildSecurityExceptionMsg(op, uid, packageName)); &#125; return mode; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 为了更好的兼容不同厂家的国产手机,建议针对不同的系统版本使用不同的权限校验策略，对于 Android 6.0以上设备，使用PermissionChecker.checkSelfPermission()进行权限校验，对于Android 6.0 以下设备，可通过触发try catch后的危险权限代码检查是否有权限，以期准确校验权限，对用户进行引导，具体可参考AndPermission等第三方库。 请求权限对于App targetSdkVersion 大于23的应用，在应用需要使用的危险权限，必须要进行动态权限申请。Android 提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框。 调用requestPermissions() 方法，可进行动态权限申请，该方法是异步的。在用户响应对话框之后，系统会回调onRequestPermissionsResult。12345678910if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; &#125; else &#123; ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); &#125;&#125; 处理权限请求回调在用户响应对话框之后，系统会回调 onRequestPermissionsResult() 方法。 123456789101112131415@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; &#125; else &#123; &#125; return; &#125; &#125;&#125; 权限申请被拒绝如果用户拒绝了某项权限请求，应用应采取适当的操作进行引导，应用应当显示一个对话框，解释应用为什么需要此权限，以及使用该权限有何影响。 当系统要求用户授予权限时，用户可以选择指统不再要求提供该权限。这种情况下，无论应用在什么时候使用 requestPermissions() 请求该权限，系统都会立即拒绝此请求。系统会调用您的 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED，如果用户再次明确拒绝了权限的请求，系统将采用相同方式操作。这意味着当调用 requestPermissions()时，不一定会出现系统权限请求弹窗。 此时可借助shouldShowRequestPermissionRationale()这个回调方法，如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。如果用户拒绝了权限请求，并在权限请求系统对话框中选择了不再询问选项，此方法将返回 false。如果设备默认禁止应用具有该权限，此方法也会返回 false。 shouldShowRequestPermissionRationale() 望文生义，是否应该显示请求权限的说明。 第一次请求权限时，用户拒绝了，调用shouldShowRequestPermissionRationale()后返回true，应该显示一些为什么需要这个权限的说明。 用户在第一次拒绝某个权限后，下次再次申请时，授权的dialog中将会出现“不再提醒”选项，一旦选中勾选了，那么下次申请将不会提示用户。 第二次请求权限时，用户拒绝了，并选择了“不再提醒”的选项，调用shouldShowRequestPermissionRationale()后返回false。 设备的策略禁止当前应用获取这个权限的授权：shouldShowRequestPermissionRationale()返回false 。 加这个提醒的好处在于，用户拒绝过一次权限后我们再次申请时可以提醒该权限的重要性，免得再次申请时用户勾选“不再提醒”并决绝，导致下次申请权限直接失败。 关于运行时权限的一些建议(1)只请求需要的权限，减少请求的次数，或用隐式Intent来让其他的应用来处理。 使用Intent，你不需要设计界面，由第三方的应用来完成所有操作。比如打电话、选择图片等。 如果请求权限，你可以完全控制用户体验，自己定义UI。但是用户也可以拒绝权限，就意味着你的应用不能执行这个特殊操作。 (2)防止一次请求太多的权限或请求次数太多，用户可能对你的应用感到厌烦，在应用启动的时候，最好先请求应用必须的一些权限，非必须权限在使用的时候才请求，建议整理并按照上述分类管理自己的权限： 普通权限（Normal PNermissions）：只需要在Androidmanifest.xml中声明相应的权限，安装即许可。 需要运行时申请的权限（Dangerous Permissions）： 必要权限：最好在应用启动的时候，进行请求许可的一些权限（主要是应用中主要功能需要的权限）。 附带权限：不是应用主要功能需要的权限(如：选择图片时，需要读取SD卡权限)。 解释你的应用为什么需要这些权限：在你调用requestPermissions()之前，你为什么需要这个权限。例如，一个摄影的App可能需要使用定位服务，因为它需要用位置标记照片。一般的用户可能会不理解，他们会困惑为什么他们的App想要知道他的位置。所以在这种情况下，所以你需要在requestpermissions()之前告诉用户你为什么需要这个权限。 (3)使用兼容库support-v4中的方法 PermissionChecker.checkSelfPermission() 或者 ContextCompat.checkSelfPermission() ActivityCompat.requestPermissions() ActivityCompat.shouldShowRequestPermissionRationale() 国产机权限问题整理 部分中国厂商生产手机（例如小米）的Rationale功能，在第一次拒绝后，第二次申请时不会返回true，并且会回调申请失败，也就是说在第一次拒绝后默认勾选了不再提示。 部分中国厂商生产手机（例如小米、华为）在申请权限时，用户点击确定授权后，还是回调我们申请失败，这个时候其实我们是拥有权限的，所以我们可以在失败的方法中使用AppOpsManager进行权限判断。 部分中国厂商生产手机（例如vivo、Oppo）在用户允许权限，并且回调了权限授权成功的方法，但是实际执行代码时并没有这个权限，建议开发者在回调成功的方法中也利用AppOpsManager判断下。 在某些手机的Setting中授权后实际检查时还是没有权限，部分执行代码也是没有权限。 从系统版本看国产机型的权限申请特点 5.0：此时 google 还未着手处理动态权限申请这么个东西，但是我们的小米、魅族等厂商就开始提前设置了强大的权限管理，所以 6.0 权限申请代码在 5.0 上压根不管用，但是说来也简单，5.0 的权限申请对话框激活就是靠触发危险权限代码，然后根据返回值来判断权限是否获取到了（不同手机的返回值判断方式不同，此处需要一一定制）。 6.0：国产大部分机型手机的申请权限实际上应该细致地分为申请权限和应用权限 。它们的 ContextCompat.checkSelfPermission(Context, String) 判断是根据是否 AndroidManifest.xml 中声明了该权限来决定返回值，在 AndroidManifest.xml 中声明了权限就返回 true，当然也会有一些会返回 false，这个是申请权限的过程。而真正对话框的弹出是在开发者应用权限的过程中，什么叫做应用权限？就是调用了会触发权限的代码，这个时候就会激活对话框，但是如果仅到这里那就 too young too simple 了，当用户点击拒绝授权时，还是可能会回调授权成功的方法。另外，国产机大部分权限是有三个状态——询问、允许、拒绝——大部分权限都是询问状态，但是有些权限默认是允许状态，有些是拒绝状态，这就导致了调用 ContextCompat.checkSelfPermission(Context, String) 方法时会更畸形，例如小米手机的获取 READ_PHONE_STATE 状态，默认是授予状态。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"Android混淆总结","slug":"Android混淆总结","date":"2017-12-23T19:27:42.000Z","updated":"2018-02-24T02:12:05.000Z","comments":true,"path":"2017/12/24/Android混淆总结/","link":"","permalink":"http://yoursite.com/2017/12/24/Android混淆总结/","excerpt":"","text":"通过代码混淆可以将项目中的类、方法、变量等信息进行重命名，变成一些无意义的简短名字，同时也可以移除未被使用的类、方法、变量等。所以直观的看，通过混淆可以提高程序的安全性，增加逆向工程的难度，同时也有效缩减了apk的体积。 开启混淆在基于Android Studio项目的app module的build.gradle中有如下默认代码片段： 1234567buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; minifyEnabled true 代表要发布的release包的混淆配置，默认不开启混淆，设为true表示开启混淆。 shrinkResources true 代表开启资源文件压缩。 proguard-android.txt 代表系统默认的混淆规则配置文件，该文件在/tools/proguard下，一般不要更改该配置文件。 proguard-rules.pro 代表当前module的混淆配置文件，可以通过修改该文件来添加当前项目的混淆规则。 编写混淆配置文件以下是系统的proguard-android.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html# 混淆时不使用大小写混合类名-dontusemixedcaseclassnames# 不跳过library中的非public的类-dontskipnonpubliclibraryclasses# 打印混淆的详细信息-verbose# Optimization is turned off by default. Dex does not like code run# through the ProGuard optimize and preverify steps (and performs some# of these optimizations on its own).# 关闭优化（原因见上边的原英文注释）-dontoptimize# 不进行预校验，可加快混淆速度-dontpreverify# Note that if you want to enable optimization, you cannot just# include optimization flags in your own project configuration file;# instead you will need to point to the# \"proguard-android-optimize.txt\" file instead of this one from your# project.properties file.# 保留注解中的参数-keepattributes *Annotation*# 不混淆如下两个谷歌服务类-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# For native methods, see http://proguard.sourceforge.net/manual/examples.html#native# 不混淆包含native方法的类的类名以及native方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# keep setters in Views so that animations can still work.# see http://proguard.sourceforge.net/manual/examples.html#beans# 不混淆View中的setXxx()和getXxx()方法，以保证属性动画正常工作-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;# We want to keep methods in Activity that could be used in the XML attribute onClick# 不混淆Activity中参数是View的方法，例如，一个控件通过android:onClick=\"clickMethodName\"绑定点击事件，混淆后会导致点击事件失效-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations# 不混淆枚举类中的values()和valueOf()方法-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 不混淆Parcelable实现类中的CREATOR字段，以保证Parcelable机制正常工作-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;# 不混淆R文件中的所有静态字段，以保证正确找到每个资源的id-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# The support library contains references to newer platform versions.# Don't warn about those in case this app is linking against an older# platform version. We know about them, and they are safe.# 不对android.support包下的代码警告（如果我们打包的版本低于support包下某些类的使用版本，会出现警告的问题）-dontwarn android.support.**# Understand the @Keep support annotation.# 不混淆Keep类-keep class android.support.annotation.Keep# 不混淆使用了注解的类及类成员-keep @android.support.annotation.Keep class * &#123;*;&#125;# 如果类中有使用了注解的方法，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;# 如果类中有使用了注解的字段，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;# 如果类中有使用了注解的构造函数，则不混淆类和类成员-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; keep关键字： 关键字 含义 keep 保留类和类成员，防止被混淆或移除 keepnames 保留类和类成员，防止被混淆，但没有被引用的类成员会被移除 keepclassmembers 只保留类成员，防止被混淆或移除 keepclassmembernames 只保留类成员，防止被混淆，但没有被引用的成员会被移除 keepclasseswithmembers 保留类和类成员，防止被混淆或移除，如果指定的类成员不存在还是会被混淆 keepclasseswithmembernames 保留类和类成员，防止被混淆，如果指定的类成员不存在还是会被混淆，没有被引用的类成员会被移除 相关通配符： 通配符 含义 * 匹配任意长度字符，但不含包名分隔符.。例如一个类的全包名路径是com.othershe.test.Person，使用com.othershe.test.、com.othershe.test.都是可以匹配的，但com.othershe.*就不能匹配 ** 匹配任意长度字符，并包含包名分隔符.。例如要匹配com.othershe.test.**包下的所有内容 * 匹配任意参数类型。例如 getName()可匹配String getName(String) … 匹配任意长度的任意类型参数。例如void setName(…)可匹配void setName(String firstName, String secondName) &lt;fileds&gt; 匹配类、接口中所有字段 &lt;methods&gt; 匹配类、接口中所有方法 &lt;init&gt; 匹配类中所有构造函数 以上就是混淆的基本语法，系统的proguard-android.txt已经为我们完成了大部分基础的混淆配置工作，至于编写当前app module下的proguard-rules.pro，只需要针对当前项目添加一些特有的配置，避免某些重要的东西被混淆掉就可以了，我们主要考虑以下几点： 在AndroidManifest.xml中注册的继承四大组件的子类的类名以及重写的方法名都不会被混淆。 比如，如果希望项目中android.support.v4.app.Fragment子类的类名和重写父类的方法名不被混淆可以添加如下配置12345# 不混淆Fragment的子类类名以及onCreate()、onCreateView()方法名-keep public class * extends android.support.v4.app.Fragment &#123; public void onCreate(android.os.Bundle); public android.view.View onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle);&#125; 不混淆某个特定的类和类中所有成员 1-keep class com.test.utils.CommonUtil &#123; *; &#125; 不混淆某个目录下的文件，例如使用Gson时，数据bean不能被混淆，需要如下配置： 12# com.test.bean代表所有bean所在的目录-keep class com.test.bean.** &#123; *; &#125; 保留泛型 1-keepattributes Signature 保留用于调试堆栈跟踪的行号信息 1-keepattributes SourceFile,LineNumberTable WebView中使用了JS调用，需要添加如下配置： 123-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125; 项目中使用的第三方库的混淆规则，这里列举几个常用的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# okhttp-dontwarn okhttp3.**-dontwarn okio.**-dontwarn javax.annotation.**-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase# Retrofit-dontwarn okio.**-dontwarn javax.annotation.**-dontnote retrofit2.Platform-dontwarn retrofit2.Platform$Java8-keepattributes Signature-keepattributes Exceptions# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Gson-keep class com.google.gson.stream.** &#123; *; &#125;-keepattributes EnclosingMethod# xxx代表model类的全包名路径-keep class xxx.** &#123; *; &#125;# butterknie-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# eventbus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; 查看混淆结果混淆后打包，会在app module/build/outputs/mapping/release目录下生成如下文件 dump.txt：描述apk文件中所有类的内部结构 mapping.txt：混淆前后的类、类成员、方法的对照关系（重要，追溯Crash堆栈信息要用到） resources.txt：资源文件的压缩信息 seeds.txt：未被混淆的类和成员 usage.txt：被移除的代码 最后还是有必要看一下混淆后的代码结构，验证混淆是否成功。一个简单的办法，Android Studio的Build菜单下有一个Analyze APK选项，只需要先选择要分析的apk包，在之后的界面点击classes.dex即可看到混淆后的代码结构： 如果看到a b c d e 这样的包名，说明已经混淆成功了。 追溯Crash信息代码混淆后，也会导致Crash堆栈信息被混淆，难以阅读，增加定位问题位置的难度，一个混淆后的Crash堆栈信息类似这样，核心的信息都没了： 为了解决这个问题，可以使用\\tools\\proguard\\bin下的proguardgui.bat脚本将Crash堆栈信息还原到混淆前的状态。步骤如下： 双击打开脚本，选择左边的ReTrace选项 选择Mapping file文件，也就是混淆后打包后在app module/build/outputs/mapping/release下生成的mapping.txt 拷贝混淆后的堆栈信息 点击右下角的ReTrace!按钮，完成Crash堆栈信息的追溯 如下图中间部分就是追溯到的原Crash堆栈信息： 代码混淆基本的内容就这些了。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"Android性能优化","slug":"Android性能优化","date":"2017-11-12T14:06:01.000Z","updated":"2018-02-24T02:11:52.000Z","comments":true,"path":"2017/11/12/Android性能优化/","link":"","permalink":"http://yoursite.com/2017/11/12/Android性能优化/","excerpt":"","text":"Android性能优化，是Android开发中的重中之中，本文将讲述如何进行性能优化。 实际项目中的Android性能优化主要有如下几个方面： 编写高效代码—开发中总结出的一些小的性能Tips Layout布局优化 内存优化 编写高效代码编写高效代码的两个原则 不要写不需要的代码 不要分配不必要的内存 以上两个原则，似乎感觉是废话，但确实是编程的最高境界，也是我们编写代码的过程中时刻需要思考和注意的两个方面。 那么如何做到如上两点呢？下面列出了一些实际开发中的例子。 避免产生不必要的对象 例如： int的数组比Integer对象数组要好得多。两个平行的int数组要比一个（int,int）型的对象数组高效。这对于其他任何基本数据类型的组合都通用 两个平行数组Foo[],Bar[]会优于一个（Foo,Bar）对象的数组 通常来讲，尽量避免创建短时零时对象.少的对象创建意味着低频的垃圾回收 对象的分配和回收都是需要代价的；分配的内存越多，就会引起强制的内存回收；给用户体验增加小的停顿间隙，从而影响用户体验。 用户能感觉到卡顿的时间延迟是100ms ~ 200ms。 用静态代替虚拟 如果方法不需要访问某对像的字段，将该方法设置为静态，调用速度会提升15%~20% 对于常量使用static final static final int i = 1;static final String s = “a”; 注：这种优化仅仅是针对基本数据类型和String类型常量的，而非任意的引用类型。但尽可能的将常量声明为static final是一种好的做法。 避免内部的getter和setter 使用增强for循环 增强for循环要比普通循环快3倍 避免使用浮点数 通常，浮点数会比整型慢2/3 在没有JIT的设备上，调用方法所传递的对象采用具体的类型而非接口类型会更高效 void methodA(List list); void methodA(ArrayList list); 如上，后一种比前一种更高效。 数据库操作方法的优化尽量利用原生的SQL语句 原生的SQL省去了拼接sql语句的步骤，要比SqliteDatabase提供的insert、query、 update、delete等函数效率高。当数据库越大，差别也越大 当操作条数较多时，利用事务进行批处理 这样SQLite将把全部要执行的SQL语句先缓存在内存当中，然后等到COMMIT的时候一次性的写入数据库，这样数据库文件只被打开关闭了一次，效率自然大大的提高 12345db.beginTransaction(); for(Collection c:colls)&#123; insert(db, c);&#125; db.setTransactionSuccessful(); Http请求方式的选择Android 内置了两种HTTP方式:HttpURLConnection 和 Apache HttpClient。这两种都支持HTTPS、流式上传和下载、可配置超时、IPv6和连接池。在Gingerbread或者更高版本时，推荐使用HttpURLConnection。 这是因为： HttpURLConnection API 更简单，包更小。同时对传输数据的压缩和响应的缓存处理减少了网络带宽、提高了速度，也节省了电量。 优化布局Layouts是Android应用里直接影响用户体验的一个关键部分。如果Layout设计的不好，可能导致你的应用大量的内存占用从而导致UI响应很慢。Android SDK提供了工具帮助你分析你的Layouts的性能问题。 使用Hierarchy Viewer Hierarchy Viewer工具位于SDK \\tools\\目录下，该工具能分析出你的布局不合理和可以优化的地方。 大多数情况下，布局渲染时间差别较大的原因是在LinaerLayout里使用了layout_weight。这将会增加测量(Measure)的时间。你应该仔细的考虑是否有必要使用layout weight。 使用Lint 使用Lint — 查看你的view层级哪些地方可以优化 使用compound drawables - 一个包含了ImageView与TextView的LinearLayout可以被当作一个compound drawable来处理 使用 - 如果FramLayout仅仅是一个纯粹的（没有设置背景，间距等）布局根元素，我们可以使用merge标签来当作根标签 无用的分支 - 如果一个layout并没有任何子组件，那么可以被移除，这样可以提高效率 无用的父控件 - 如果一个layout只有子控件，没有兄弟控件，并且不是一个ScrollView或者根节点，而且没有设置背景，那么我们可以移除这个父控件，直接把子控件提升为父控件 深层次的layout - 尽量减少内嵌的层级，考虑使用更多平级的组件 RelativeLayout or GridLayout来提升布局性能，默认最大的深度是10 其他一些布局要点 使用include标签 使用ViewStub标签 优化App内存为了垃圾回收器能回收你系统的内存，你应该避免引起内存泄露，而且要在合适的时间点释放被引用的对象。 慎用Service Service执行完后台任务后要停止 使用IntentService IntentService不同于普通的Service之处是： 提交的task系统会post到子线程运行 当后台运行的task完成时，系统会stop掉IntentService Release memory when your user interface becomes hidden 例如，在该onStop（）里做释放资源（例如网络连接、注销广播等）的工作 使用优化后的集合容器 例如：SparseArray、SparseBooleanArray、LongSpareArray ….. 尽量避免使用枚举 相比于静态常量，枚举会有超过其两倍以上的内存开销，在android中需严格避免使用枚举 避免使用依赖注入框架 使用ProGuard消除没有使用的代码 使用zipalign优化和对齐你的apk 使用MAT分析和优化内存 I/O使用后需要关闭，数据库和Cursor等使用后要关闭 使用finalize()+MAT 分析内存泄露 end Android优化主要就是内存、布局和性能的优化，本文总结了Android中优化的一些知识点。如果还有其他我没有讲到的，欢迎给我留言。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"给RecyclerView加上折叠的效果","slug":"给RecyclerView加上折叠的效果","date":"2017-10-20T20:37:21.000Z","updated":"2018-02-24T02:11:35.000Z","comments":true,"path":"2017/10/21/给RecyclerView加上折叠的效果/","link":"","permalink":"http://yoursite.com/2017/10/21/给RecyclerView加上折叠的效果/","excerpt":"","text":"RecyclerView 有很高的自由度，可以说只有想不到没有做不到。这次用超简单的方法，让 RecyclerView 带上折叠的效果。 效果是这样的。 总结一下这个列表的特点，就是以下三点： 重叠效果； 层次感； 首项的差动。下面我们来一个个解决。 我们新建一个 ParallaxRecyclerView，让它继承 RecyclerView，并使用 LinearLayoutManager 作为布局管理器。 重叠效果 其实就是每一项都搭一部分在它前面那项而已。我们知道，RecyclerView 可以通过设置 ItemDecoration来实现列表的间隔效果，有没有想过要是把间隔设为负数会怎么样？比如： 1234567addItemDecoration(new ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom = -dp2px(context, 10); &#125; &#125;); 没错，这就实现了我们的重叠效果。 层次感 在 Material Design里是有Z轴这个概念的，我们可以给控件设置垂直于屏幕的高度，让不在同一高度的控件看起来有层次感。当然，我们要用 Material Design 的控件才有这个属性，这里我用的是 CardView。 我们给 ParallaxRecyclerView 增加一个滑动监听，在 onScrolled 方法里面做如下设置： 12345678910111213141516LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();int firstPosition = layoutManager.findFirstVisibleItemPosition();int lastPosition = layoutManager.findLastVisibleItemPosition();int visibleCount = lastPosition - firstPosition;//重置控件的高度int elevation = 1;for (int i = firstPosition - 1; i &lt;= (firstPosition + visibleCount) + 1; i++) &#123; View view = layoutManager.findViewByPosition(i); if (view != null) &#123; if (view instanceof CardView) &#123; ((CardView) view).setCardElevation(dp2px(context, elevation)); elevation += 5; &#125; &#125;&#125; 其中，setCardElevation 方法就是用来给 CardView 设置高度的，这里让每一项的高度比它的上一项高 5dp。 首项的差动 最后，我们想给第一项增加一个差动效果，这个同样在 onScrolled方法里面做处理就好了： 123View firstView = layoutManager.findViewByPosition(firstPosition);float firstViewTop = firstView.getTop();firstView.setTranslationY(-firstViewTop / 2.0f); 这样相当于第一项的滑动速度变成原来的一半。但这也会导致一个问题， 由于改变了控件的位置，当这个控件被复用时，会出现位置不正确的情况。所以我们在设置高度的时候，可以顺便把控件的位置复原了： 1234float translationY = view.getTranslationY();if (i &gt; firstPosition &amp;&amp; translationY != 0) &#123; view.setTranslationY(0);&#125; 这样就完成了一个带有简单折叠效果的 RecyclerView 了，妥妥的。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Service总结","slug":"Service总结","date":"2017-09-27T20:14:37.000Z","updated":"2018-02-24T02:12:29.000Z","comments":true,"path":"2017/09/28/Service总结/","link":"","permalink":"http://yoursite.com/2017/09/28/Service总结/","excerpt":"","text":"启动Service的方式 Context.startService(Intent)： 12Intent intent = new Intent(this, PlayService.class);startService(intent); Context.bindService(Intent,ServiceConnection,BIND_AUTO_CREATE) 12345678910111213private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e(\"result\",\"绑定成功\"); PlayService.MyBinder binder = (PlayService.MyBinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e(\"result\",\"解绑成功\"); &#125;&#125;;Intent intent = new Intent(this,PlayService.class);bindService(intent,conn,BIND_AUTO_CREATE); 两种启动方式区别： startService启动之后，如果没有调用stopSelf()或者stopService()就会一直在后台运行。bindService启动Service之后，在启动它的组件被销毁后也会解绑并销毁。 startService()启动Service到结束，Service经历生命周期的是onCreate()、onStartCommand()、onDestory()。而bindService()启动Service，Service经历的生命周期是onCreate()、onBind()、onUnbind()、onDestory() 如果即startService又bindService启动了Service，要分别unBindService()、stopSelf()/stopService()关闭Service。这里关闭没有顺序限制的，比如：先startService，后bindService。结束时先进行unBindService，stopService，还是顺序反过来都是没有问题的。 启动之后再次启动的生命周期 在startService之后，再进行startService，只会再次执行Service的onStartCommond方法，而不会再执行onCreate 在bindService之后，再进行bindService，不会再执行Service的onBind。 和Activity交互 Activity在启动Service的时候，可以通过Intent.putExtra来给Service传递数据(两种方式均可) 通过bindService()启动Service，通过onBind()返回的Binder来指挥Service来进行操作 123class MyBinder extends Binder&#123; public void action()&#125; Service给Activity回传数据，可以通过在Service中发送广播，在Activity注册广播接收数据 Service是运行在UI线程的 如果需要在Service中做耗时操作，需要另外起一个线程。 当然你还可以使用IntentService IntentServiceIntentService优点如下 Service中的事情处理完成之后，它会调用stopSelf()结束自己 Service可以直接处理耗时操作 IntentService的基本使用如下：1234567891011121314151617181920212223public class DownloadService extends IntentService &#123; public DownloadService() &#123; super(\"DownLoadService\"); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.e(\"result\", \"onCreate\"); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; super.onStart(intent, startId); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; Log.e(\"result\", \"onStartCommand\"); return super.onStartCommand(intent, flags, startId); &#125; @Override protected void onHandleIntent(Intent intent) &#123; Log.e(\"result\", \"onHandleIntent\"); &#125;&#125; 需要注意的是：它的构造方法必须给他提供一个无参构造方法，名字就命名为类名即可。 IntentService的原理 IntentService封装了HandlerThread和Handler，HandlerThread就是一个Thread（具体再分析），Handler handler = new Handler(handerThread.getLooper())，handler是由子线程中的Looper构造的，相当于在子线程中有个一个MessageQueue消息队列，我们每次startService()，就是sendMessage()添加一个消息到队列中，然后该childThread的Looper不断的从MessageQueue中取出消息去处理。 记住：Handler构造中的Looper在哪个线程，该Handler就为哪个线程服务。如果是无参构造就是MainThread，因为内部调用了looper.myLooper()。 补充onStartCommand()方法的返回值问题： START_STICKY：如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。 START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。 START_REDELIVER_INTENT：重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。 START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"Android通用流行框架大全","slug":"Android通用流行框架大全","date":"2017-09-09T21:56:39.000Z","updated":"2018-02-24T02:10:54.000Z","comments":true,"path":"2017/09/10/Android通用流行框架大全/","link":"","permalink":"http://yoursite.com/2017/09/10/Android通用流行框架大全/","excerpt":"","text":"1. 缓存 名称 描述 DiskLruCache Java实现基于LRU的磁盘缓存 Robospice 2.图片加载 名称 描述 Android Universal Image Loader 一个强大的加载，缓存，展示图片的库 Picasso 一个强大的图片下载与缓存的库 Fresco 一个用于管理图像和他们使用的内存的库 Glide 一个图片加载和缓存的库 3. 图片处理 名称 描述 Picasso-transformations 一个为Picasso提供多种图片变换的库 Glide-transformations 一个为Glide提供多种图片变换的库 Android-gpuimage 基于OpenGL的Android过滤器 4. 网络请求 名称 描述 Android Async HTTP Android异步HTTP库 AndroidAsync 异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。 OkHttp 一个Http与Http/2的客户端 Retrofit 类型安全的Http客户端 Volley Google推出的Android异步网络请求框架和图片加载框架 5. 网络解析 名称 描述 Gson 一个Java序列化/反序列化库，可以将JSON和java对象互相转换 Jackson Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象 Fastjson Java上一个快速的JSON解析器/生成器 HtmlPaser 一种用来解析单个独立html或嵌套html的方式 Jsoup 一个以最好的DOM，CSS和jQuery解析html的库 6. 数据库 名称 描述 OrmLite JDBC和Android的轻量级ORM java包 Sugar 用超级简单的方法处理Android数据库 GreenDAO 一种轻快地将对象映射到SQLite数据库的ORM解决方案 ActiveAndroid 以活动记录方式为Android SQLite提供持久化 SQLBrite SQLiteOpenHelper 和ContentResolver的轻量级包装 Realm 移动数据库：一个SQLite和ORM的替换品 7. 依赖注入 名称 描述 ButterKnife 将Android视图和回调方法绑定到字段和方法上 Dagger2 一个Android和java快速依赖注射器。 AndroidAnotations 快速安卓开发。易于维护 RoboGuice Android平台的Google Guice 8. 图表 名称 描述 WilliamChart 创建图表的Android库 HelloCharts 兼容到API8的Android图表库 MPAndroidChart 一个强大的Android图表视图/图形库 9. 后台处理 名称 描述 Tape 一个轻快的，事务性的，基于文件的FIFO的库 Android Priority Job Queue 一个专门为Android轻松调度任务的工作队列 10. 事件总线 名称 描述 EventBus 安卓优化的事件总线，简化了活动、片段、线程、服务等的通信 Otto 一个基于Guava的增强的事件总线 11. 响应式编程 名称 描述 RxJava JVM上的响应式扩展 RxJavaJoins 为RxJava提供Joins操作 RxAndroid Android上的响应式扩展，在RxJava基础上添加了Android线程调度 RxBinding 提供用RxJava绑定Android UI的API Agera Android上的响应式编程 12. Log框架 名称 描述 Logger 简单，漂亮，强大的Android日志工具 Hugo 在调试版本上注解的触发方法进行日志记录 Timber 一个小的，可扩展的日志工具 Xutils 13. 测试框架 名称 描述 Mockito Java编写的Mocking单元测试框架 Robotium Android UI 测试 Robolectric Android单元测试框架 Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等 14. 调试框架 名称 描述 Stetho 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试 15. 性能优化 名称 描述 LeakCanary 内存泄漏检测工具 ACRA Android应用程序崩溃报告 16. 数据统计 名称 描述 友盟统计 百度统计 17. 崩溃收集 名称 描述 腾讯bugly bugtags 18. 即时通讯 名称 描述 环信 融云 阿里百川 19. 推送 名称 描述 小米推送 极光推送 个推 20. 内嵌浏览器 名称 描述 腾讯X5内核 百度T5内核","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"http和https","slug":"http和https","date":"2017-08-20T20:33:46.000Z","updated":"2018-02-24T02:10:28.000Z","comments":true,"path":"2017/08/21/http和https/","link":"","permalink":"http://yoursite.com/2017/08/21/http和https/","excerpt":"","text":"HTTP基础 超文本传输协议（HTTP，HyperText Transfer Protocol），默认端口：80 特点 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 请求报文 一般由请求行、请求头、空行、请求体四部分组成。 响应报文 一般由状态行、消息报头、空行、响应正文四部分组成。 常见状态码 200 OK：客户端请求成功 302 Move temporarily：请求的资源临时从不同的 URI响应请求，重定向 304 Not Modified：有效缓存 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现 500 Internal Server Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 常见通用报头 Cache-Control：指定请求和响应遵循的缓存机制 常用请求报头 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接 Referer：允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等 Range：可以请求实体的一个或者多个子范围 常见响应报头 Location：用于重定向接受者到一个新的位置，常用在更换域名的时候Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的 常见实体报头 Content-Type：发送给接收者的实体正文的媒体类型 Content-Lenght：实体正文的长度 Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制 Last-Modified：实体报头用于指示资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间 SPDY 2012年google提出的SPDY方案，主要解决： 降低延迟：SPDY采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式； 请求优先级：SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应； header压缩：选择合适的压缩算法可以减小包的大小和数量； 基于HTTPS的加密协议传输 服务端推送 Http2.0 可以看成是SPDY的升级版。 Http2.0与SPDY的区别 HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE Http2.0新特性 新的二进制格式：HTTP1.x的解析是基于文本的 多路复用：即连接共享，即每一个request都是是用作连接共享机制的 header压缩 服务端推送 HTTPS (Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，即HTTP下加入SSL层，端口：443 HTTPS握手流程 客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息； 服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书； 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步； 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器； 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器； 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）； 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化； 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束； 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束； SSL 的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 Android中处理Https处理 javax.net.ssl.SSLHandshakeException: 证书验证失败 123456789101112131415161718192021222324252627282930313233343536/** * HTTPS未知的证书颁发机构处理方法 * Android客户端存储证书 * * @param input 待信任的CA证书流 * @return SSLContext */public static SSLContext getSSLContext(InputStream input) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); Certificate ca = cf.generateCertificate(input); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setCertificateEntry(\"ca\", ca); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(keyStore); sslContext.init(null, tmf.getTrustManagers(), null); input.close(); return sslContext; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null;&#125; 单独使用SSL和HTTP 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 单独使用SSL + HTTP时 * @param trustManagers * @return */public static SSLContext getSSLContext(TrustManager[] trustManagers) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagers, null); return sslContext; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return null;&#125;public static TrustManager[] sDefaultTrustManagers = new TrustManager[] &#123;new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; // TODO: 2018/1/23双向校验中，向服务端发客户端证书 &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; // TODO: 2018/1/23 双向校验中，校验服务端证书 &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125;&#125;&#125;;public static HostnameVerifier sHostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; // 不验证主机名 return true; &#125;&#125;;","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"Android消息机制(Handler)","slug":"Android消息机制-Handler","date":"2017-07-12T20:20:05.000Z","updated":"2018-02-24T02:10:07.000Z","comments":true,"path":"2017/07/13/Android消息机制-Handler/","link":"","permalink":"http://yoursite.com/2017/07/13/Android消息机制-Handler/","excerpt":"","text":"答疑解惑 系统为什么不允许在子线程中访问UI？ Android的UI控件不是线程安全的 增加上锁机制会导致: UI访问逻辑复杂、降低UI访问效率 区分线程的数据存储 ThreadLocal 工作原理MessageQueue 内部由单链表实现，主要包含两个操作：插入(enqueueMessage)和读取(next)。 Looper 从MessageQueue中不停查看是否有新消息，如果有新消息立即处理。 系统已经为主线程创建了Looper，可以使用getMainLooper获取 其他线程使用Looper.prepare()获取，使用Looper.loop()启动 loop方法是一个死循环，运行在创建Looper的线程 Handler 负责发送和接收消息。可以通过post和send方法发送消息，post方法最终也会走入send的逻辑。 Handler工作过程: Handler消息处理流程:","categories":[],"tags":[{"name":"通信","slug":"通信","permalink":"http://yoursite.com/tags/通信/"}]},{"title":"匿名类用到的变量为什么一定要是final的呢?","slug":"匿名类用到的变量为什么一定要是final的呢","date":"2017-06-11T19:47:16.000Z","updated":"2018-02-24T02:09:45.000Z","comments":true,"path":"2017/06/12/匿名类用到的变量为什么一定要是final的呢/","link":"","permalink":"http://yoursite.com/2017/06/12/匿名类用到的变量为什么一定要是final的呢/","excerpt":"","text":"提起final变量，大家通常知道这些： final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 final类不能被继承，没有子类，final类中的方法默认是final的。 final方法不能被子类的方法覆盖，但可以被继承。 final不能用于修饰构造方法 final 常与 static一起用，作为常量来使用。 提问：在一些方法的参数中定义为final是干嘛的? 答: 不希望这个变量在方法里面被修改，防止无意的修改而影响到调用方法外的变量。 不知道这个答案是从哪个语言带过来的， 感觉把final当成const了。 假设出现以下方法定义:12void fuc(final String string);void fuc1(String string); 对于这种写法，String本身就是一个不可以变的对象，并且其是作为基本参数类型，传参进入后，方法里面改变了String的值外面也不会改变，因此这两种写法实际结果是一样.只不过加了final，在string被赋值时IDE会直接报红。12void fuc(final A a);void fuc(A a); 对于这种写法， A是一个对象，这样写不是代表A里面内容不能被改变，而是a不能被赋值为新对象了. 为什么使用匿名内部类的时候参数一定要加上final让我们写一个类看一下1234567891011121314151617public class Test &#123; class Person &#123; String name; int age; &#125; private void func(final Person a) &#123; new Thread() &#123; @Override public void run() &#123; super.run(); a.name = \"hello\"; &#125; &#125;.start(); &#125;&#125; javac一下该文件，生成了3个class文件，我们看其中的两个 内部类Person的class12345678class Test$Person &#123; String name; int age; Test$Person(Test var1) &#123; this.this$0 = var1; &#125;&#125; 匿名内部类Thread的class1234567891011class Test$1 extends Thread &#123; Test$1(Test var1， Person var2) &#123; this.this$0 = var1; this.val$a = var2; &#125; public void run() &#123; super.run(); this.val$a.name = \"hello\"; &#125;&#125; 从这个匿名内部类的class文件我们可以看出两点 其构造参数中增加了一个调用类.即我们所说的持有外部类的引用. 我们定义的final参数被当做构造方法传了进来.至于为什么要把这个参数当做构造函数参数传进来，因为调用它的方法参数是存在栈里面的，其生命周期随着这个方法的调用结束而结束.而我们的异步任务可不是，有可能会执行很长时间。 那么final的关键字作用就凸显了，Person参数要拷贝到内部类中，而拷贝会带来不一致性， func中是一个异步的操作，负责改变a的name的值. 假设Person a 不是final的.那么a可以被任意指向新的对象，那么传给这个异步任务的对象还是老对象，这就造成了不一致.因此Java需要强制约束对象的一致性.因此必须是final的。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"通过H5唤起本地app","slug":"通过H5唤起本地app","date":"2017-05-08T21:33:43.000Z","updated":"2018-02-24T02:09:19.000Z","comments":true,"path":"2017/05/09/通过H5唤起本地app/","link":"","permalink":"http://yoursite.com/2017/05/09/通过H5唤起本地app/","excerpt":"","text":"H5如何打开或者说唤起手机本地的app，有以下两种： 第一种方式： 通过在html的a标签里面的href中直接配置android端的schema，当然，如果有host其他的配置，跟在后面就可以了，android端配置和代码如下： android端配置：12345678910111213&lt;activity android:name = \".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name = \"android.intent.action.MAIN\"/&gt; &lt;category android:name = \"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;data android:host=\"baidu.com\" android:scheme=\"testapp\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 注：如果这个是配置在启动页要和标签并列在一起，不然运行后手机app的图标会没有；注意schema协议要小写,否则会有不能响应的异常! html代码： 123456789&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"testapp://baidu.com/?pid=1\"&gt;打开app&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 这里我们来看看schema拼接协议的格式： &lt; a href=”[scheme]://[host]/[path]?[query]”&gt;启动应用程序&lt; /a&gt; 各个项目含义如下所示： scheme：判别启动的App。 host：适当记述 path：传值时必须的key ※没有也可以 query：获取值的Key和Value ※没有也可以 以上就能实现打开本地的app了，当然是在app存在的情况下，否则的话没有反应。 我们有些时候在唤起本地app的时候可能会向app传递一些参数，这些参数我们就可以配置在path或者query里，我们只需要在oncreate里面获取就可以了。 代码如下： 12345Intent intent = getIntent(); Uri uri = intent.getData(); if (uri != null) &#123; String pid = uri.getQueryParameter(\"pid\");&#125; 如果还想要获取android里面配置的schema协议的话，还可以这样: 12345678910111213141516171819202122232425Uri uri = getIntent().getData();if(uri != null) &#123; // 完整的url信息 String url = uri.toString(); Log.e(TAG, \"url: \" + uri); // scheme部分 String scheme = uri.getScheme(); Log.e(TAG, \"scheme: \" + scheme); // host部分 String host = uri.getHost(); Log.e(TAG, \"host: \" + host); //port部分 int port = uri.getPort(); Log.e(TAG, \"host: \" + port); // 访问路径 String path = uri.getPath(); Log.e(TAG, \"path: \" + path); List&lt;String&gt; pathSegments = uri.getPathSegments(); // Query部分 String query = uri.getQuery(); Log.e(TAG, \"query: \" + query); //获取指定参数值 String pid = uri.getQueryParameter(\"pid\"); Log.e(TAG, \"pid: \" + pid);&#125; 如何判断一个Schema是否有效 : 1234567PackageManager packageManager = getPackageManager();Intent intent = newIntent(Intent.ACTION_VIEW, Uri.parse(\"testapp://baidu.com:80/article?goodsId=10011002\"));List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(intent, 0);booleanisValid = !activities.isEmpty();if(isValid) &#123; startActivity(intent);&#125; 这种方式也是我百度到的最多的方式，但是这样就带来了一个问题了，上面的需求说的是“在页面上有一个连接， 如果用户安装了APP，则点击打开对应的APP；如果用户没有安装，则点击打开对应的设置连接”，这明显就不符合需求了，这只能作为一些个别需求来使用了。 第二种方式： 既然通过在href配置schema协议不行，那就只能通过js代码来实现了，只有这样才能根据判断实现app有的时候就打开，没有的时候就跳转到下载链接下载。 我们知道，js是无法判断手机是否安装了某款app的，所以我们只能够曲线救国了，我们可以获取时间如果，长时间不能呼起app则默认为没有安装这款app，然后跳转到下载页。当然这不是我想出来的，是网上的各位大佬的想法。在这里又要细分为两种情况了。 1.直接唤醒 说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式兼容性较好，如果安装了app，在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器、QQ浏览器、百度浏览器 )和QQ客户端中，能唤醒。微信、新浪微博客户端、腾讯微博客户端无法唤醒。 代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;点击唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL，点击按钮，打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面，通过点击的方式。兼容性较好，如果安装了app，在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )和QQ客户端中，能唤醒。微信 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;a href=\"zjmobile://platformapi/startapp\" id=\"zjmobliestart\" target=\"_blank\"&gt;唤醒浙江移动手机营业厅！&lt;/a&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; return function()&#123; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;; &#125;applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.点击唤醒 说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面。兼容性一般：在手机各大浏览器(360浏览器、uc浏览器、搜狗浏览器 QQ浏览器、百度浏览器 )能唤醒。微信、QQ客户端、新浪微博客户端、 腾讯微博客户端无法唤醒。 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt;&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.9.0/jquery.js\"&gt;&lt;/script&gt;&lt;title&gt;直接唤醒demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#zjmobliestart&#123;font-size:40px;&#125;&lt;/style&gt;&lt;!--说明：通过h5可换醒app，如访问一个URL就能直接打开应用，如果该应用APP没有安装，那么直接跳转到App Store的APP下载页面兼容性一般：在手机各大浏览器(360浏览器 uc浏览器 搜狗浏览器 QQ浏览器 百度浏览器 )能唤醒。微信 QQ客户端 新浪微博客户端 腾讯微博客户端无法唤醒。--&gt;&lt;p id=\"zjmobliestart\"&gt;唤醒浙江移动手机营业厅！&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; function applink()&#123; window.location = 'zjmobile://platformapi/startapp'; var clickedAt = +new Date; setTimeout(function()&#123; !window.document.webkitHidden &amp;&amp; setTimeout(function()&#123; if (+new Date - clickedAt &lt; 2000)&#123; window.location = 'https://itunes.apple.com/us/app/zhe-jiang-yi-dong-shou-ji/id898243566#weixin.qq.com'; &#125; &#125;, 500); &#125;, 500) &#125;document.getElementById(\"zjmobliestart\").onclick = applink();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样就完成了我们的需求了。 还要注意的是，如果是在微信中唤起本地app，手机的微信中，是利用微信内置的浏览器打开那个简单的HTML页面，注意：直接打开scheme://host/datastring是不可行的，微信不会把这串字符解析成网址，必须包装成网页才能借助微信的浏览器打开。进入后就是我们刚刚设计的页面。这个时候，直接点击“启动应用程序”是不会唤醒之前安装的APP的，因为微信做了屏蔽，你需要在右上角的菜单中选择“在浏览器中打开”。这个时候就可以唤醒你想唤醒的app了。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"Android中的各种Span","slug":"Android中的各种Span","date":"2017-04-16T20:38:02.000Z","updated":"2018-02-24T02:08:46.000Z","comments":true,"path":"2017/04/17/Android中的各种Span/","link":"","permalink":"http://yoursite.com/2017/04/17/Android中的各种Span/","excerpt":"","text":"简介在android.text.style包下,有一些Span类,可以提供我们完成一些在TextView中的特殊内容。(比如:部分内容颜色、字体、大小不同等等)。本篇博客主要讲解一些span的用法，以及结合Android动画机制制作出十分酷炫的动画Span。 给字符添加边框FrameSpan实现给相应的字符序列添加边框的效果，整体思路其实比较简单。 计算字符序列的宽度； 根据计算的宽度、上下坐标、起始坐标绘制矩形； 绘制文字 展现效果如下所示： 再来看一下代码，其实代码十分简单。12345678910111213141516171819202122public class FrameSpan extends ReplacementSpan &#123; private final Paint mPaint; private int mWidth; public FrameSpan() &#123; mPaint = new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLUE); mPaint.setAntiAlias(true); &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123; //return text with relative to the Paint mWidth = (int) paint.measureText(text, start, end); return mWidth; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; //draw the frame with custom Paint canvas.drawRect(x, top, x + mWidth, bottom, mPaint); canvas.drawText(text, start, end, x, y, paint); &#125;&#125; 用法示例：1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); final SpannableString spannableString = new SpannableString( \"helloworld,helloworld!helloworld,helloworld!helloworld,\" + \"helloworld!helloworld,helloworld!\"); spannableString.setSpan(new FrameSpan(), 0, 30, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 图文垂直居中系统提供的ImageSpan和DynamicDrawableSpan只能实现图片和文字底部对齐或者是baseline对齐，现在VerticalImageSpan可以实现图片和文字居中对齐。 图中的图片保持了和文字居中对齐，现在来看看VerticalImageSpan的源码。123456789101112131415161718192021222324252627282930313233343536public class VerticalImageSpan extends ImageSpan &#123; private Drawable drawable; public VerticalImageSpan(Drawable drawable) &#123; super(drawable); this.drawable=drawable; &#125; @Override public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fontMetricsInt) &#123; Drawable drawable = getDrawable(); if(drawable==null)&#123; drawable= this.drawable; &#125; Rect rect = drawable.getBounds(); if (fontMetricsInt != null) &#123; Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt(); int fontHeight = fmPaint.bottom - fmPaint.top; int drHeight = rect.bottom - rect.top; int top = drHeight / 2 - fontHeight / 4; int bottom = drHeight / 2 + fontHeight / 4; fontMetricsInt.ascent = -bottom; fontMetricsInt.top = -bottom; fontMetricsInt.bottom = top; fontMetricsInt.descent = top; &#125; return rect.right; &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Drawable drawable = getDrawable(); canvas.save(); int transY = ((bottom - top) - drawable.getBounds().bottom) / 2 + top; canvas.translate(x, transY); drawable.draw(canvas); canvas.restore(); &#125;&#125; 在geSize方法中通过fontMetricsInt设置从而实现图片和文字居中对齐，其实计算的根本为计算baseline的位置，因为TextView是按照baseline对齐的。 分析getSize方法可以知道这个图片的baseline为图片中央往下fontHeight / 2，这样也就实现了图片和文字的居中对齐。 用法示例：12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); Drawable drawable = getResources().getDrawable(R.drawable.ic_launcher); drawable.setBounds(0, 0, 50, 50); final SpannableString spannableString = new SpannableString( \"helloworld,helloworld!helloworld,helloworld!helloworld,\" + \"helloworld!helloworld,helloworld!\"); spannableString.setSpan(new VerticalImageSpan(drawable), 0, 1, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 字体多色渐变彩虹样的Span，其实实现起来也是很简单的，主要是用到了Paint的Shader技术，效果如下所示： 源代码如下所示：123456789101112131415private static class RainbowSpan extends CharacterStyle implements UpdateAppearance &#123; private final int[] colors; public RainbowSpan(Context context) &#123; colors = context.getResources().getIntArray(R.array.rainbow); &#125; @Override public void updateDrawState(TextPaint paint) &#123; paint.setStyle(Paint.Style.FILL); Shader shader = new LinearGradient(0, 0, 0, paint.getTextSize() * colors.length, colors, null, Shader.TileMode.MIRROR); Matrix matrix = new Matrix(); matrix.setRotate(90); shader.setLocalMatrix(matrix); paint.setShader(shader); &#125;&#125; 由于paint使用shader是从上到下进行绘制，因此这里需要用到矩阵，然后将矩阵旋转90度。 用法示例：1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = findViewById(R.id.id_tv_framespan); final SpannableString spannableString = new SpannableString( &quot;helloworld,helloworld!helloworld,helloworld!helloworld,&quot; + &quot;helloworld!helloworld,helloworld!&quot;); spannableString.setSpan(new RainbowSpan(this), 0, 40, Spanned.SPAN_INCLUSIVE_INCLUSIVE); tv.setText(spannableString);&#125; 字体多色渐变动画效果 如果要实现一个动画的彩虹样式，那么该如何实现呢？ 其实结合上面的RainbowSpan和AnimateForegroundColorSpan的例子便可以实现AnimatedRainbowSpan。 实现思路：通过ObjectAnimator动画调整RainbowSpan中矩阵的平移，从而实现动画彩虹的效果。 代码如下所示： 首先是AnimatedColorSpan1234567891011121314151617181920212223242526272829private static class AnimatedColorSpan extends CharacterStyle implements UpdateAppearance &#123; private final int[] colors; private Shader shader = null; private Matrix matrix = new Matrix(); private float translateXPercentage = 0; public AnimatedColorSpan(Context context) &#123; colors = context.getResources().getIntArray(R.array.rainbow); &#125; public void setTranslateXPercentage(float percentage) &#123; translateXPercentage = percentage; &#125; public float getTranslateXPercentage() &#123; return translateXPercentage; &#125; @Override public void updateDrawState(TextPaint paint) &#123; paint.setStyle(Paint.Style.FILL); float width = paint.getTextSize() * colors.length; if (shader == null) &#123; shader = new LinearGradient(0, 0, 0, width, colors, null, Shader.TileMode.MIRROR); &#125; matrix.reset(); matrix.setRotate(90); matrix.postTranslate(width * translateXPercentage, 0); shader.setLocalMatrix(matrix); paint.setShader(shader); &#125; &#125;&#125; 配合属性动画：1234567891011121314151617181920212223242526272829303132333435363738public class AnimatedRainbowSpanActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animated_rainbow_span); final TextView textView = (TextView) findViewById(R.id.text); String text = textView.getText().toString(); AnimatedColorSpan span = new AnimatedColorSpan(this); final SpannableString spannableString = new SpannableString(text); String substring = getString(R.string.animated_rainbow_span).toLowerCase(); int start = text.toLowerCase().indexOf(substring); int end = start + substring.length(); spannableString.setSpan(span, start, end, 0); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat( span, ANIMATED_COLOR_SPAN_FLOAT_PROPERTY, 0, 100); objectAnimator.setEvaluator(new FloatEvaluator()); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; textView.setText(spannableString); &#125; &#125;); objectAnimator.setInterpolator(new LinearInterpolator()); objectAnimator.setDuration(DateUtils.MINUTE_IN_MILLIS * 3); objectAnimator.setRepeatCount(ValueAnimator.INFINITE); objectAnimator.start(); &#125;private static final Property&lt;AnimatedColorSpan, Float&gt; ANIMATED_COLOR_SPAN_FLOAT_PROPERTY = new Property&lt;AnimatedColorSpan, Float&gt;(Float.class, \"ANIMATED_COLOR_SPAN_FLOAT_PROPERTY\") &#123; @Override public void set(AnimatedColorSpan span, Float value) &#123; span.setTranslateXPercentage(value); &#125; @Override public Float get(AnimatedColorSpan span) &#123; return span.getTranslateXPercentage(); &#125;&#125;; 打字效果 有了上面的例子，写TypeWriterSpan就变得十分简单了。 先创建TypeWriterSpanGroup1234567891011121314151617181920212223242526272829public class TypeWriterSpanGroup &#123; private final float mAlpha; private final ArrayList&lt;MutableForegroundColorSpan&gt; mSpans; public TypeWriterSpanGroup(float alpha) &#123; mAlpha = alpha; mSpans = new ArrayList&lt;MutableForegroundColorSpan&gt;(); &#125; public void addSpan(MutableForegroundColorSpan span) &#123; span.setAlpha((int) (mAlpha * 255)); mSpans.add(span); &#125; public void setAlpha(float alpha) &#123; int size = mSpans.size(); float total = 1.0f * size * alpha; for(int index = 0 ; index &lt; size; index++) &#123; MutableForegroundColorSpan span = mSpans.get(index); if(total &gt;= 1.0f) &#123; span.setAlpha(255); total -= 1.0f; &#125; else &#123; span.setAlpha((int) (total * 255)); total = 0.0f; &#125; &#125; &#125; public float getAlpha() &#123; return mAlpha; &#125;&#125; 然后添加Span与添加动画，整体使用示例如下：1234567891011121314151617181920212223242526@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextView tv = findViewById(R.id.id_tv_framespan); String val = \"helloworld,helloworld!helloworld,helloworld!helloworld\"; final SpannableString spannableString = new SpannableString(val); // 添加Span final TypeWriterSpanGroup group = new TypeWriterSpanGroup(0); for(int index = 0 ; index &lt;= val.length()-1 ; index++) &#123; MutableForegroundColorSpan span = new MutableForegroundColorSpan(); group.addSpan(span); spannableString.setSpan(span, index, index + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; // 添加动画 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(group, TYPE_WRITER_GROUP_ALPHA_PROPERTY, 0.0f, 1.0f); objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //refresh tv.setText(spannableString); &#125; &#125;); objectAnimator.setDuration(5000); objectAnimator.start();&#125; 动画属性变化器代码如下：1234567891011private static final Property&lt;TypeWriterSpanGroup, Float&gt; TYPE_WRITER_GROUP_ALPHA_PROPERTY = new Property&lt;TypeWriterSpanGroup, Float&gt;(Float.class, \"TYPE_WRITER_GROUP_ALPHA_PROPERTY\") &#123; @Override public void set(TypeWriterSpanGroup spanGroup, Float value) &#123; spanGroup.setAlpha(value); &#125; @Override public Float get(TypeWriterSpanGroup spanGroup) &#123; return spanGroup.getAlpha(); &#125; &#125;; 涉及到的类：12345678910111213141516171819public class MutableForegroundColorSpan extends CharacterStyle implements UpdateAppearance &#123; public static final String TAG = \"MutableForegroundColorSpan\"; private int mColor = Color.BLACK; private int mAlpha = 0 ; @Override public void updateDrawState(TextPaint tp) &#123; tp.setColor(mColor); tp.setAlpha(mAlpha); &#125; public int getColor() &#123; return mColor; &#125; public void setColor(int color) &#123; this.mColor = color; &#125; public void setAlpha(int alpha) &#123; mAlpha = alpha; &#125;&#125;","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]},{"title":"实现上滑屏幕，隐藏底部菜单栏","slug":"实现上滑屏幕，隐藏底部菜单栏","date":"2017-03-25T22:02:50.000Z","updated":"2018-02-24T02:08:18.000Z","comments":true,"path":"2017/03/26/实现上滑屏幕，隐藏底部菜单栏/","link":"","permalink":"http://yoursite.com/2017/03/26/实现上滑屏幕，隐藏底部菜单栏/","excerpt":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。","text":"实现列表上滑的同时，隐藏底部菜单栏，下滑的同时，显示底部菜单栏。本文主要实现的功能是底部菜单栏随用户手势滑动而变化。 正常状态 上滑之后 布局代码这个功能实现起来比较简单，主要利用了CoordinatorLayout的layout_behavior的属性。具体代码如下： 123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/toolbar\"/&gt; &lt;include layout=\"@layout/container\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/bottom_navigation\" style=\"@style/Widget.Design.BottomNavigationView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_gravity=\"bottom\" android:background=\"@color/viewBackground\" app:elevation=\"16dp\" app:itemIconTint=\"@drawable/nav_item_color_state\" app:itemTextColor=\"@drawable/nav_item_color_state\" app:layout_behavior=\"com.testapp.widget.behavior.BottomNavigationBehavior\" app:menu=\"@menu/bottom_navigation_main\"/&gt; 上面是activity_main的布局代码，第一个是菜单栏，第二个是内容界面，第三个是bottom。bottom导航栏这里采用是BottomNavigationView，具体用法不再介绍。这里主要看一下BottomNavigationView的app:layout_behavior属性，该属性是协调布局特有的。网上的一版用法是 1app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" 虽然表面上看是一个字符串，其实在里面调用的也是一个view类。这次我们通过自定义这个behavior类，实现底部菜单栏的显隐性。 java实现类1234567891011121314151617181920212223242526272829303132333435public class BottomNavigationBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private ObjectAnimator outAnimator, inAnimator; public BottomNavigationBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; // 垂直滑动 @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0) &#123;// 上滑隐藏 if (outAnimator == null) &#123; outAnimator = ObjectAnimator.ofFloat(child, \"translationY\", 0, child.getHeight()); outAnimator.setDuration(200); &#125; if (!outAnimator.isRunning() &amp;&amp; child.getTranslationY() &lt;= 0) &#123; outAnimator.start(); &#125; &#125; else if (dy &lt; 0) &#123;// 下滑显示 if (inAnimator == null) &#123; inAnimator = ObjectAnimator.ofFloat(child, \"translationY\", child.getHeight(), 0); inAnimator.setDuration(200); &#125; if (!inAnimator.isRunning() &amp;&amp; child.getTranslationY() &gt;= child.getHeight()) &#123; inAnimator.start(); &#125; &#125; &#125;&#125; 这个类的就是刚刚那个app:layout_behavior=”com.meiji.toutiao.widget.behavior.BottomNavigationBehavior”属性标明的类，看起来很简单，继承了Behavior抽象类，然后实现了两个方法。 onStartNestedScroll：这个方法主要用于监听协调布局的子view的滚动事件，当此方法返回true，表示要消耗此动作，继而执行下面的onNestedPreScroll方法，我们在代码中返回的是，滚动轴是不是竖直滚动轴。如果是的话，就返回trueonNestedPreScroll：这个方法就比较简单了，当用户上滑的时候，隐藏底部菜单栏，这里使用了动画退出，使用了ObjectAnimator.ofFloat方法，第一个是view对象，指的就是bottom，第二个是Y轴的变化，第三个是Y轴变化的多少，接下来设置动画秒数。","categories":[],"tags":[{"name":"控件","slug":"控件","permalink":"http://yoursite.com/tags/控件/"}]}]}