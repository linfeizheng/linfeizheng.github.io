---
title: 'Java面试题'
date: 2018-05-18 11:36:26
---
#### Switch能否用string做参数？
在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。

#### equals与==的区别?
==比较的是2个对象的地址，而equals比较的是2个对象的内容。

#### String、StringBuffer与StringBuilder的区别?
StringBuilder：线程非安全的 、StringBuffer：线程安全的
a.如果要操作少量的数据用 = String
b.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 
c.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

#### Collection与Collections的区别?
Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。
Collection是个java.util下的接口，它是各种集合结构的父接口。

#### Override和Overload的含义去区别?
Overload：函数里面有相同的函数名但是参数名、返回值、类型不相同。
Override：在子类继承父类的时候，将方法继承过来。

#### interface与abstract类的区别?
1. 抽象类可以有构造方法，接口中不能有构造方法。
2. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的。
3. 抽象类中可以包含静态方法，接口中不能包含静态方法。
4. 一个类可以实现多个接口，但只能继承一个抽象类。
5. 都不能被实例化。
6. 接口里只能定义常量，不能定义普通成员变量；抽象类里则即可以定义普通成员变量，也可以定义静态常量。

#### 解析XML的几种方式?
DOM、SAX、PULL

#### 设计模式六大原则?
要点 | 定义 | 描述
---|---|---
单一职责原则 | 不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 | 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。
里氏替换原则 |    定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。定义2：所有引用基类的地方必须能透明地使用其子类的对象。 | 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
依赖倒置原则 | 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 | 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。
接口隔离原则 | 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 | 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
迪米特法则 | 一个对象应该对其他对象保持最少的了解。 | 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。解决方案：尽量降低类与类之间的耦合。

#### 常用到的设计模式?
1. 单例模式

懒汉式

``` java
//懒汉式单例类.在第一次调用的时候实例化自己   
public class Singleton {  
    private Singleton() {}  
    private static Singleton single=null;  
    //静态工厂方法   
    public static Singleton getInstance() {  
         if (single == null) {    
             single = new Singleton();  
         }    
        return single;  
    }  
}  
```

饿汉式

``` java
//饿汉式单例类.在类初始化时，已经自行实例化   
public class Singleton {  
    private Singleton() {}  
    private static final Singleton single = new Singleton();  
    //静态工厂方法   
    public static Singleton getInstance() {  
        return single;  
    }  
} 
```
2. 适配器模式
3. 观察者模式
4. 建造者模式